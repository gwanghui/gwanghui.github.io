<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="GwangHui Park"><meta name="copyright" content="GwangHui Park"><title>History | Gwang Story</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">GwangHui Park</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">103</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">47</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">12</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Gwang Story</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Gwang Story</div><div id="site-sub-title">History</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2021/01/05/java-date-timestamp/">java-date-timestamp</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-01-05</time><div class="content"><h3 id="java-8-이전"><a class="markdownIt-Anchor" href="#java-8-이전"></a> Java 8 이전</h3>
<ul>
<li>java.sql.Date</li>
<li>java.sql</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/12/15/web-import-on-interaction-pattern/">web-import-on-interaction-pattern</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-15</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/web/">web</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/security/">security</a></span><div class="content"><h2 id="the-import-on-interaction-pattern"><a class="markdownIt-Anchor" href="#the-import-on-interaction-pattern"></a> The Import on interaction pattern</h2>
<ul>
<li>
<p>user-centric performance metrics for measuring</p>
<ul>
<li><a href="https://web.dev/fid/" target="_blank" rel="noopener">First Input Delay : FID</a> : within 100ms
<ul>
<li>how fast your site loads can be measured with <a href="https://web.dev/fcp/" target="_blank" rel="noopener">First Contentful Paint : FCP</a></li>
<li>the render time of the largest image or text block visible within the viewport <a href="https://web.dev/lcp/" target="_blank" rel="noopener">Largest Contentful Paint: LCP</a></li>
</ul>
</li>
<li><a href="https://web.dev/lighthouse-total-blocking-time/" target="_blank" rel="noopener">Total Blocking Time : TBT</a></li>
<li><a href="https://web.dev/interactive/" target="_blank" rel="noopener">Total to Interactive : TTI</a></li>
</ul>
</li>
<li>
<p>The different ways to load resources are, at a high-level</p>
<ul>
<li>Eager - load resource right away (the normal way of loading scripts)</li>
<li>Lazy (Route-based) - load when a user navigates to a route or component</li>
<li>Lazy (On interaction) - load when the user clicks UI (e.g Show Chat)</li>
<li>Lazy (In viewport) - load when the user scrolls towards the component</li>
<li>Prefetch - load prior to needed, but after critical resources are loaded</li>
<li>Preload - eagerly, with a greater level of urgency</li>
</ul>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/02/new-house-interior/">new-house-interior</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-02</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/interior/">interior</a></span><div class="content"><h2 id="단창-이중창-발코니-전용창"><a class="markdownIt-Anchor" href="#단창-이중창-발코니-전용창"></a> 단창, 이중창, 발코니 전용창</h2>
<h3 id="창호-업체-종류"><a class="markdownIt-Anchor" href="#창호-업체-종류"></a> 창호 업체 종류</h3>
<ul>
<li>LG ,KCC, 한화, 이건, 영림</li>
</ul>
<h3 id="low-emissivity-유리"><a class="markdownIt-Anchor" href="#low-emissivity-유리"></a> Low-Emissivity 유리</h3>
<ul>
<li><a href="https://brunch.co.kr/@jhsiwo/111" target="_blank" rel="noopener">https://brunch.co.kr/@jhsiwo/111</a></li>
</ul>
<h3 id="복층유리"><a class="markdownIt-Anchor" href="#복층유리"></a> 복층유리</h3>
<ul>
<li>두께 : 16T, 18T, 22T, 24T</li>
<li><a href="https://m.blog.naver.com/nanumwin/221177795208" target="_blank" rel="noopener">https://m.blog.naver.com/nanumwin/221177795208</a></li>
<li><a href="https://m.blog.naver.com/sashsuridotcom/220835029218" target="_blank" rel="noopener">https://m.blog.naver.com/sashsuridotcom/220835029218</a></li>
<li><a href="http://shinhodong1.cafe24.com/?page_id=12730" target="_blank" rel="noopener">http://shinhodong1.cafe24.com/?page_id=12730</a></li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/10/30/invitation-software-architecture/">invitation-software-architecture-1</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-30</time><div class="content"><h1 id="아키텍처-설계와-상세-설계"><a class="markdownIt-Anchor" href="#아키텍처-설계와-상세-설계"></a> 아키텍처 설계와 상세 설계</h1>
<ul>
<li>아키텍처 기반 개발
<ul>
<li>요구사항</li>
<li>아키텍처</li>
<li>상세설계</li>
<li>구현</li>
</ul>
</li>
<li>설계 차이점
<ul>
<li>기능 요구 사항 (전통 설계) vs 도메인 개체 식별 및 서브 시스템 그룹핑(객체 설계) vs 품질 요구사항 (아키 설계)
<ul>
<li>도메인 개체 식별 및 서브 시스템 그룹핑 정의는 재사용성과 유지 보수성의 반영에 지나지 않는다.</li>
<li>요구되는 다양한 품질 충족에 주된 관심사를 두고 이들 간의 상충관계를 분석하고 대안 아키텍처 전략 중 선택</li>
</ul>
</li>
<li>아키 기반 설계 : 컴포넌트들의 식별과 커넥터들의 구성에 초점</li>
<li>객체 기반 설계 : 객체의 식별로 부터 시작(bottom-up)</li>
</ul>
</li>
</ul>
<h1 id="architecture-12-factors"><a class="markdownIt-Anchor" href="#architecture-12-factors"></a> architecture 12 factors</h1>
<h2 id="아키텍처-드라이버"><a class="markdownIt-Anchor" href="#아키텍처-드라이버"></a> 아키텍처 드라이버</h2>
<ul>
<li>시스템 요구사항(System Requirement)의 분류
<ul>
<li>기능 요구사항 (functional Requirement) : 시스템이 특정한 입력에 대해 어떻게 반응하고 특정 상황에서 어떻게 동작해야 하는가를 기술</li>
<li>비기능 요구사항(non-functional Requirement)
<ul>
<li>품질 요구사항(quality requirement) : 성능(Performance), 신뢰성(Reliability), 사용용이성(Usability), 진화성(Evolvability), 확장개발성(extensibility), 규모확장성(scalability)</li>
<li>제약사항(constraints) : 개발시간, 개발공정, 준수하여야 하는 표준</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="아키텍처-프레임-드라이버"><a class="markdownIt-Anchor" href="#아키텍처-프레임-드라이버"></a> 아키텍처 프레임 드라이버</h3>
<ul>
<li>개발대상 시스템의 도메인, 환경 및 추상수준을 결정하는 요소</li>
<li>개발 대상 소프트웨어가 존재하는 context에 따라 설계 대상 아키텍처가 들어가는 적절한 아키텍처 프레임이 달라진다.</li>
<li>아키텍처 프레임을 결정짓는 아키텍처 프레임 드라이버가 있다.
<ul>
<li>ex) “개발대상 소프트웨어는 지역적으로 분산된 정보시스템이다.” , “J2EE를 기반으로 한 클라이언트 서버 형 분산 소프트웨어 등이다.”</li>
</ul>
</li>
</ul>
<h2 id="품질속성-검증가능성-품질-속성-시나리오"><a class="markdownIt-Anchor" href="#품질속성-검증가능성-품질-속성-시나리오"></a> 품질속성, 검증가능성, 품질 속성 시나리오</h2>
<h3 id="품질속성"><a class="markdownIt-Anchor" href="#품질속성"></a> 품질속성</h3>
<ul>
<li>고객들이 요구하는 품질 요구사항들은 다양하며 이들을 분류할 수 있는 명칭을 가진다 이를 품질속성 (quality attribute)라고 부른다.
<ul>
<li>“시스템이 하루 23시간 이상 서비스를 제공하여야 한다” 는 요구사항이 있다면 이를 간략히 가용성(availability)이라는 품질속성 명칭을 이용하여 &quot;시스템이 높은 가용성을 가져야 한다&quot;고 말할 수 있다.</li>
</ul>
</li>
<li>품질속성 종류
<ul>
<li>개발 관정 : 재사용성, 변경용이성, 확장개발성, 유지보수성, 이식성, 구축용이성, 시험용이성, 이해용이성</li>
<li>실행 관점 : 신뢰성, 성능, 가용성, 사용용이성, 안전성, 보안성, 규모확장성</li>
</ul>
</li>
</ul>
<h3 id="검증가능성"><a class="markdownIt-Anchor" href="#검증가능성"></a> 검증가능성</h3>
<ul>
<li>요구사항 충족여부를 판단할 수 있는가?</li>
<li>품질 요구사항이 검증 가능한 형태를 가지고 있지 않다면 검증 가능한 형태로 먼저 가공해야한다.</li>
</ul>
<h3 id="품질-시나리오-템플릿"><a class="markdownIt-Anchor" href="#품질-시나리오-템플릿"></a> 품질 시나리오 템플릿</h3>
<ul>
<li>소스(source) : 자극(stimulus)을 생성하는 개체</li>
<li>자극(stimulus) : 시스템에 영향을 주는 조건</li>
<li>산출물(artifact) : 자극에 의하여 영향을 받는 시스템의 부분</li>
<li>환경(environment) : 자극이 발생한 조건</li>
<li>반응(response) : 자극 때문에 발생하는 활동</li>
<li>반응척도(response measure) : 시스템의 반응을 평가하는 척도</li>
</ul>
<h2 id="아키텍처-설계-문제-분석"><a class="markdownIt-Anchor" href="#아키텍처-설계-문제-분석"></a> 아키텍처 설계 문제 분석</h2>
<ul>
<li>아키텍처 설계문제의 식별, 정리 및 해결책의 후보를 도출하는 활동</li>
</ul>
<h3 id="아키텍처-설계문제-분석원"><a class="markdownIt-Anchor" href="#아키텍처-설계문제-분석원"></a> 아키텍처 설계문제 분석원</h3>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/10/29/agile-facilitating/">agile-facilitating</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-29</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/agile/">agile</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/facilitating/">facilitating</a></span><div class="content"><h2 id="facilitating-example"><a class="markdownIt-Anchor" href="#facilitating-example"></a> facilitating example</h2>
<ul>
<li>그룹원간 친목도모
<ul>
<li>참석자 : 5인</li>
<li>시간 : 50분</li>
<li>목적 : 친목도모 활동 계획 수립</li>
</ul>
</li>
</ul>
<h3 id="time-table"><a class="markdownIt-Anchor" href="#time-table"></a> Time Table</h3>
<ul>
<li>10시 반 (점심시간 전 50분 타임어택)
<ul>
<li>10분 : 아이스 브레이킹 (커피 사러 나가기)</li>
<li>15분 : 브레인 스토밍(다과, 음료, 장소, 식사 4가지 카테고리로 발산형 대화)</li>
<li>15분 : jk methods, payoff matrix 만들기</li>
<li>10분 : 리스트 선정 및 계획 수립</li>
</ul>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/10/29/designing-data-intensive-application-8/">designing-data-intensive-application-8</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-29</time><div class="content"><h3 id="분산-시스템에서의-비관주의"><a class="markdownIt-Anchor" href="#분산-시스템에서의-비관주의"></a> 분산 시스템에서의 비관주의</h3>
<ul>
<li>어떤 것이든지 잘못될 가능성이 있다면 잘못된다.</li>
</ul>
<h3 id="결함과-부분-장애"><a class="markdownIt-Anchor" href="#결함과-부분-장애"></a> 결함과 부분 장애</h3>
<ul>
<li>하드웨어가 올바르게 동작하면 같은 연산은 항상 같은 결과를 낸다(결정적이다.).</li>
<li>분산 시스템에서 시스템의 어떤 부분은 잘 동작하지만 다른 부분은 예측할 수 없는 방식으로 고장나는 것을 부분 장애(partial failure)라고 한다.</li>
<li>부분장애는 비결정적이라서 다루기가 어렵다.</li>
</ul>
<h3 id="클라우드-컴퓨팅과-슈퍼-컴퓨팅"><a class="markdownIt-Anchor" href="#클라우드-컴퓨팅과-슈퍼-컴퓨팅"></a> 클라우드 컴퓨팅과 슈퍼 컴퓨팅</h3>
<ul>
<li>대규모 컴퓨팅의 끝에는 고성능 컴퓨팅(high-performance computing, HPC)분야가 있다.</li>
<li>다른 극단에는 클라우드 컴퓨팅이 있다.</li>
<li>전통적인 기업형 데이터센터는 이 두 극단의 중간 지점에 있다.</li>
</ul>
<h3 id="인터넷-서비스를-구현하는-것은-집중으로-할때의-관점"><a class="markdownIt-Anchor" href="#인터넷-서비스를-구현하는-것은-집중으로-할때의-관점"></a> 인터넷 서비스를 구현하는 것은 집중으로 할때의 관점</h3>
<ul>
<li>
<p>언제라도 사용자에게 지연 시간이 낮은 서비스를 제공해야 한다.<br />
수리를 위해 클러스터를 중단시키는 것처럼 서비스를 이용할수 없게 하는 것은 허용되지 않는다.</p>
</li>
<li>
<p>슈퍼 컴퓨터는 전형적으로 특화된 하드웨어를 사용해 구축한다. 노드는 신뢰성이 높고 공유메모리, remote direct memory access를 사용해 통신한다.<br />
반면, 클라우드 서비스의 노드는 사용ㅇ 장비를 사용해 구축한다. 규모의 경제 덕에 낮은 비용으로 동일한 성능을 제공하지만 실패율이 높다.</p>
</li>
<li>
<p>거대한 데이터선테의 네트워크는 흔히 IP와 이더넷을 기반으로 하며, 높은 양단 대역폭(bisection bandwidth)를 제공하기 위해 Clos topology로 연결되어 있다.<br />
슈퍼컴퓨터는 통신 패턴이 정해진 HPC 작업부하에서 높은 성능을 보여주는 다차원 Mesh나 torus 같은 특화 네트워크 토폴로지를 자주 사용한다.</p>
</li>
</ul>
<h3 id="신뢰성-없는-네트워크"><a class="markdownIt-Anchor" href="#신뢰성-없는-네트워크"></a> 신뢰성 없는 네트워크</h3>
<ul>
<li>각 장비는 자신만의 메모리와 디스크를 갖고 있고 다른 장비의 메모리나 디스크에 접근할 수 없다고 가정</li>
<li>asynchronous packet network (비동기 패킷 네트워크) : 노드는 다른 노드로 메시지(패킷)를 보낼 수 있지만 네트워크는 메시지가 언제 도착할지 혹은 메시지가 도착히기는 할 것인지 보장하지 않는다.
<ul>
<li>요청이 손실됐을 수 있다. (누군가 네트워크 케이블을 뽑았을지도 모른다.)</li>
<li>요청이 큐에서 대기하다가 나중에 전송될 수 있다. (네트워크나 수신자에 과부하가 걸렸을 수 있다.)</li>
<li>원격 노드에 장애가 생겼을 수 있다.(죽었거나 전원이 나갔을 수 있다.)</li>
<li>원격 노드가 일시적으로 응답하기를 멈췄지만 나중에는 다시 응답하기 시작할 수 있다.</li>
<li>원격 노드가 요청을 처리했지만 응답이 네트워크에서 손실됐을 수 있다.</li>
<li>원격 노드가 요청을 처리했지만 응답이 지연되다가 나중에 전송될 수 있다. (네트워크나 수신자에 과부하가 걸렸을 수 있다.)</li>
</ul>
</li>
<li>비동기 네트워크에서 이런 문제를 다루는 흔한 방법은 타임아웃이다.</li>
</ul>
<h3 id="현실의-네트워크-결함"><a class="markdownIt-Anchor" href="#현실의-네트워크-결함"></a> 현실의 네트워크 결함</h3>
<ul>
<li>인적 오류</li>
<li>스위치의 소프트웨어 업그레이드 중 생기는 문제는 네트워크 토폴로지 재구성을 유발</li>
<li>상어가 해저 케이블을 물어 뜯음</li>
<li>수신 패킷은 전부 누락, 송신 패킷은 잘 보내는 네트워크 인터페이스가 있음 (네트워크 링크가 한 방향으로 동작한다고 해서 반대 방향도 동작하리라고 보장되는 것은 아님)</li>
<li>반드시 네트워크 결함을 견뎌내도록(tolerating) 처리할 필요는 없다.</li>
<li>그러나 시스템이 그로부터 복구할 수 있도록 보장해야 한다.</li>
</ul>
<h3 id="결함-감지"><a class="markdownIt-Anchor" href="#결함-감지"></a> 결함 감지</h3>
<ul>
<li>많은 시스템은 결함 있는 노드를 자동으로 감지할 수 있어야 한다.
<ul>
<li>로드 밸런서는 죽은 노드로 요청을 그만 보내야 한다</li>
<li>단일 리더 복제를 사용하는 분산 데이터베이스에서 리더에 장애가 나면 팔로워 중 하나가 리더로 승격돼야 한다.</li>
</ul>
</li>
<li>특정한 상황에서는 뭔가 동작하지 않는다고 명시적으로 알려주는 피드백을 받을 수 있다.
<ul>
<li>노드가 실행 중인 장비에 연결할 수는 있지만 목적지 포트에서 수신 대기하는 프로세스가 없다면 운영체제가 RST, FIN패킷을 보내 TCP 연결을 닫거나 거부한다. 그러나 노드가 요청을 처리하다 죽었다면 데이터가 실제로 얼마나 처리 됐는지 알 방법이 없다.</li>
<li>노드 프로세스가 죽었지만 노드의 운영체제는 아직 실행 중이라면 스크립트로 다른 노드에게 프로세스가 죽었다고 알려서 다른 노드가 타임아웃이 만료되기를 기다릴 필요 없이 빠르게 역할을 넘겨 받을 수 있게 할 수 있다. (HBASE)</li>
<li>데이터센터 내 네트워크 스위치 관리 인터페이스에 접근할 수 있으면 질의를 보내 하드웨어 수준의 링크 장애를 감지 할 수 있다.</li>
<li>접속하려는 IP 주소에 도달할 수 없다고 라우터가 확신하면 ICMP Destination Unreachable 패킷으로 응답할 수도 있다. 그러나 라우터가 마법 같은 장애 감지 능력이 없다면 네트워크의 다른 참여자들과 동일한 제한이 적용된다.</li>
<li>원격 노드가 다운되고 있다는 빠른 피드백은 유용하지만 여기에 의존할 수는 없다. TCP가 패킷이 전달됐다는 확인 응답(ack)을 했더라도 애플리케이션이 그것을 처리하기 전에 죽을 수 있다.
<ul>
<li>요청이 성공했음을 확신하고 싶다면 애플리케이션 자체로부터 긍정 응답을 받아야 한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="타임아웃과-기약-없는-지연"><a class="markdownIt-Anchor" href="#타임아웃과-기약-없는-지연"></a> 타임아웃과 기약 없는 지연</h3>
<ul>
<li>타임아웃이 길면 노드가 죽었다고 선언될 때까지 기다리는 시간이 길어진다.
<ul>
<li>타임아웃이 짧으면 결함을 빨리 발견하지만 노드가 일시적으로 느려졌을 뿐인데도 죽었다고 잘못 선언할 위험이 높아진다.</li>
<li>성급하게 노드가 죽었다고 선언하면 문제가 된다. 노드가 실제로는 살아 있고 어떤 동작을 실행하는 중일 때 다른 노드가 역할을 넘겨 받으면 그 동작을 두 번 실행하게 될 지도 모른다.</li>
<li>노드가 죽었다고 선언되면 그 노드의 책무는 다른 노드로 전달돼야 해서 다른 노드와 네트워크 추가적인 부하를 준다.
<ul>
<li>시스템이 높은 부하에 허덕이는 중이라면 성급하게 노드가 죽었다고 선언하는 것은 문제를 악화시킬 수 있다. 노드가 실제로는 죽지 않았고 과부하 때문에 응답이 느릴뿐일 수도 있다.</li>
<li>만약 그 노드의 부하를 다른 노드로 전달하면 연쇄 장애를 유발할 수 있다.</li>
</ul>
</li>
</ul>
</li>
<li>비동기 네트워크는 기약 없는 지연(unbounded delay)가 있고, 서버 구현은 대부분 어떤 최대 시간 내에 요청을 처리한다고 보장할 수 없다.</li>
<li>시스템이 대부분의 시간에 빠르다는 것은 장애 감지에 충분치 않다.</li>
</ul>
<h3 id="네트워크-혼잡과-큐-대기"><a class="markdownIt-Anchor" href="#네트워크-혼잡과-큐-대기"></a> 네트워크 혼잡과 큐 대기</h3>
<ul>
<li>여러 다른 노드가 동시에 같은 목적지로 패킷을 보내려고 하면 네트워크 스위치는 패킷을 큐에 넣고 한 번에 하나씩 목적지 네트워크 링크로 넘겨야 한다.
<ul>
<li>Network congestion(네트워크 혼잡) : 네트워크 링크가 붐비면 패킷은 슬롯을 얻을 수 있을 때까지 잠시 기다려야 할 수도 있다.</li>
</ul>
</li>
<li>패킷이 목적지 장비에 도착했을 때 모든 CPU 코어가 바쁜 상태라면 네트워크에서 들어온 요청은 애플리케이션에서 처리할 준비가 될 때까지 운영체제가 큐에 넣어둔다.</li>
<li>가상 환경에서 실행되는 운영체제는 다른 가상 장비가 CPU 코어를 사용하는 동안 수십 밀리초 동안 멈출 때가 흔하다. 이 시간 동안 가상 장비는 네트워크에서 어떤 데이터도 받아들일 수 없으므로 가상 장비 모니터가 들어오는 데이터를 큐에 넣어서 네트워크 지연의 변동성을 더욱 증가시킨다.</li>
<li>TCP는 흐름 제어(Flow Control)를 수행한다. Congestion avoidance(혼잡 회피)나 Backpressure(배압) 이라고도 하는 흐름 제어는 노드가 네트워크 링크나 수신 노드에 과부하를 가하지 않도록 자신의 송신율을 제한하는 것이다.</li>
<li>데이터가 네트워크로 들어가기 전에도 부가적인 큐 대기를 할 수 있다는 뜻이다.</li>
<li>공개 클라우드와 멀티 테넌트 데이터센터에서는 여러 소비자가 자원을 공유한다. 네트워크 링크와 스위치, 각 장비의 네트워크 인터페이스와 CPU도 공유한다.
<ul>
<li>MapReduce(맵리듀스) 같은 일괄 처리 작업 부하는 네트워크 링크를 포화시키기 쉽다. 공유된 자원을 다른 사용자가 사용하는 것을 제어하거나 간파할 수 없으므로 자원을 많이 사용하는 누군가가 가까이 있다면 네트워크 지연 변동이 클 수 있다.</li>
<li>위와 같은 환경에서는 실험적으로 타임아웃을 선택하는 수 밖에 없다. 애플리케이션의 특성을 고려해 장애 가밎 지연과 너무 이른 타임아웃의 위험성 사이에서 적절한 트레이드오프를 결정할 수 있다.</li>
<li>더 좋은 방법은 고정된 타임아웃을 설정하는 대신 시스템이 지속적으로 응답 시간과 그들의 변동성(Jitter)을 측정하고 관촬된 응답 시간 분포에 따라 타임아웃을 자동으로 조절하게 하는 것이다.
<ul>
<li>Phi Accrual failure detector(파이 증가 장애 감지기)를 쓰면 된다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="패킷-교환-방식"><a class="markdownIt-Anchor" href="#패킷-교환-방식"></a> 패킷 교환 방식</h3>
<ul>
<li>Bursty traffic(순간적으로 몰리는 트래픽)에 최적화
<ul>
<li>Quality of Service : 패킷에 우선순위를 매기고 스케쥴링</li>
<li>Admission control(진입 제어) : 전송 측에서 전송률을 제한</li>
</ul>
</li>
</ul>
<h3 id="신뢰성-없는-시계"><a class="markdownIt-Anchor" href="#신뢰성-없는-시계"></a> 신뢰성 없는 시계</h3>
<ul>
<li>시계와 시간은 중요하다. 애플리케이션은 다음과 같은 질문에 대답하기 위해 다양한 방식으로 시계에 의존한다.
<ul>
<li>이 요청이 타임아웃됐나?</li>
<li>이 서비스의 99분위 응답 시간은 어떻게 되나?</li>
<li>이 서비스는 지난 5분 동안 평균 초당 몇개의 질의를 처리했나?</li>
<li>사용자가 우리 사이트에서 시간을 얼마나 보냈나?</li>
<li>이 기사가 언제 게시됐나?</li>
<li>며칠 몇 시에 미리 알림 이메일을 보내야 하나?</li>
<li>이 캐시 항목은 언제 만료되나?</li>
<li>로그 파일에 남은 이 오류 메세지의 타임스탬프는 무엇인가?</li>
</ul>
</li>
<li>네트워크에 있는 개별 장비는 자신의 시계를 갖고 있다.
<ul>
<li>보통 Quartz crystal oscillator(수정 발진기)이다. 이 장치는 완벽하지는 않아서 각 장비는 자신만의 시간 개념이 있으며 이는 다른 장비보다 약간 빠를 수도 느릴 수도 있다.</li>
<li>시간을 동기화 할때 Network Time Protocol(NTP)로 서버 그룹에서 보고한 시간에 따라 컴퓨터 시계를 조정 할 수 있게 한다. 이 서버들은 GPS 수신자 같은 더욱 정확한 시간 출처로부터 시간을 얻는다.</li>
</ul>
</li>
</ul>
<h3 id="단조-시계-대-일-기준-시계"><a class="markdownIt-Anchor" href="#단조-시계-대-일-기준-시계"></a> 단조 시계 대 일 기준 시계</h3>
<ul>
<li>일 기준 시계(time of day clock)
<ul>
<li>어떤 달력에 따라 현재 날짜와 시간을 반환한다.</li>
<li>Linux의 clock_gettime(CLOCK_REALTIME)과 자바의 System.currentTimeMillis()는 epoch(에포크) 이래로 흐른 밀리초 수를 반환한다.</li>
<li>윤초는 세지 않고 에포크는 그레고리력을 따랐을 경우 UTC(협정세계시) 1970년 1월 1일 자정을 가리킨다.</li>
<li>NTP 동기화한다.</li>
<li>Coarse-grained 해상도를 가진다. 예를 들어 오래된 윈도우 시스템에서는 10밀리초 단위로 흐른다. 최근의 시스템에서는 이게 별 문제가 되진 않는다.</li>
</ul>
</li>
<li>단조 시계(monotonic clock)
<ul>
<li>단조 시계라는 이름은 항상 앞으로 흐른다는 사실에서 나왔다.</li>
<li>Linux의 clock_gettime(CLOCK_MONOTONIC)과 자바의 System.nanoTime()이 있다.</li>
<li>한 시점에서 단조 시계의 값을 확인하고 어떤 일을 한 후 나중에 다시 시계를 확인할 수 있다. 두 값사이의 차이로 두 번의 확인 사이에 얼마나 시간이 흘렀는지 알 수 있다.</li>
<li>그러나 시계의 절대적인 값은 의미가 없다. 컴퓨터가 시작한 이래 흐른 나노초 수일 수도 있고 비슷한 어떤 것일 수도 있다. <em>두개의 다른 컴퓨터에서 나온 단조 시계 값을 비교하는 것은 의미가 없다.</em></li>
<li>여러 개의 CPU 소켓이 있는 서버는 CPU마다 독립된 타이머가 있을 수도 있다. 이 타이머는 다른 CPU와 반드시 동기화되는 것은 아니다. 운영체제는 차이를 보정해서 애플리케이션 스레드가 여러 CPU에 걸쳐 스케쥴링 되더라도 시계가 단조적으로 보이게 하려 노력한다.</li>
<li>그러나 단조성 보장은 곧이 곧대로 받아들이지 않는 게 현명하다.</li>
<li>NTP는 컴퓨터의 로컬 시계가 NTP 서버보다 빠르거나 느리다는 것을 발견하면 단조 시계가 진행하는 진도수를 조정할 수도 있다. 기본적으로 NTP는 시계 속도를 0.05%까지 올리거나 내리는 것을 허용하지만 단조 시계가 앞이나 뒤로 뛰게 할 수는 없다.</li>
<li>단조 시계의 해상도는 보통 상당히 좋아 마이크로초나 그 이하 단위로 측정이 가능하다.</li>
<li>분산 시스템에서 경과 시간을 재는 데 단조 시계를 쓰는 것은 일반적으로 괜찮다. 다른 노드의 시계 사이에 동기화가 돼야 한다는 가정이 없고 측정이 약간 부정확해도 민감하지 않기 때문이다.</li>
</ul>
</li>
</ul>
<h3 id="시계-동기화와-정확도"><a class="markdownIt-Anchor" href="#시계-동기화와-정확도"></a> 시계 동기화와 정확도</h3>
<ul>
<li>컴퓨터의 수정 시계는 아주 정확하지는 않다. Drift 현상이 생기며 시계 드리프트는 장비의 온도에 따라 변한다.</li>
<li>구글은 자신들의 서버에 200ppm(parts per million)의 시계 드리프트가 있다고 가정한다.</li>
<li>컴퓨터 시계가 NTP 서버와 너무 많은 차이가 나면 동기화가 거부되거나 시계가 강제로 리셋될 수도 있다. 리셋 전 후에 시간을 관찰한 애플리케이션은 시간이 거꾸로 흐르거나 갑자기 앞으로 뛰는 것을 볼지도 모른다.</li>
<li>NTP 동기화는 잘해야 네트워크 지연만큼만이 좋을 수 있다. 혼잡한 네트워크에서는 정확도에 한계가 있다.</li>
<li>윤초가 발생하면 1분의 길이가 59초나 61초가 되어 윤초를 고려하지 않고 설계된 시스템에서는 시간에 관한 가정이 엉망이 되어버린다.
<ul>
<li>현실에서 실제 NTP 서버의 동작은 다양하지만 윤초를 처리하는 최선의 방법은 윤초 조정을 하루에 걸쳐서 서서히 수행함으로써 NTP서버가 “거짓말을 하게” 하는 것일 수도 있다. (Smearing(문지름)이라고 부른다)</li>
</ul>
</li>
<li>고빈도 트레이딩 펀드는 UTC와 100마이크로초 이내로 동기화를 요구하고 이는 Flash Crash(플래시 크래시 : 주가나 채권 금리가 급락하는 상황)같은 시장 이상 현상을 디버깅하고 시장 조작을 감지하는 데 도움되게 만들기 위해서다.</li>
</ul>
<h3 id="동기화된-시계에-의존하기"><a class="markdownIt-Anchor" href="#동기화된-시계에-의존하기"></a> 동기화된 시계에 의존하기</h3>
<ul>
<li>NTP 클라이언트가 잘못 설정됐다면 시계는 드리프트가 생겨서 점점 실제 시간으로부터 멀어져 가지만 대부분이 잘 동작하는 것처럼 보인다.</li>
<li>동기화된 시계가 필요한 스프트웨어를 사용한다면 필수적으로 모든 장비 사이의 시계차이를 모니터링 해야한다.</li>
<li>다른 노드와 시계가 너무 차이나는 노드는 죽은 것으로 선언되고 클러스터에서 제거 돼야 한다.</li>
</ul>
<p><img src="/images/data-intensive/chapter_8/event_ordered_timestamp.png" alt="" /></p>
<h3 id="충돌-해소-전략"><a class="markdownIt-Anchor" href="#충돌-해소-전략"></a> 충돌 해소 전략</h3>
<ul>
<li>Last Write Wins(LWW : 최종 쓰기 승리)
<ul>
<li>다중 리더 복제와 카산드라와 리악같은 리더 없는 데이터베이스에서 널리 사용된다.</li>
<li>데이터베이스 쓰기가 불가사의하게 사라질 수 있다. 시계가 뒤처지는 노드는 시계가 빠른 노드가 먼저 쓴 내용을 그들 사이에 차이나는 시간이 흐를 때까지 덮어쓸 수 없다.</li>
<li>LWW는 순차적인 쓰기가 빠른 시간 내에 연속으로 실행되는 것과 진짜 동시에 쓰기가 실행 되는 것을 구별할 수 없다. 인과성 위반을 막으려면 버전 벡터 같은 부가적인 인과성 추적 메커니즘이 필요하다.</li>
<li>두 노드가 독립적으로 동일한 타임스탬프를 가진 쓰기 작업을 만들 수도 있다. 시계의 해상도가 밀리초 단위 밖에 안되면 그렇다. 같은 값을 다르게 만들어줄 부가적인 값이 필요하지만 이 방법도 인과성 위반으로 이어질 수 있다.</li>
</ul>
</li>
</ul>
<h3 id="전역-스냅숏용-동기화된-시계"><a class="markdownIt-Anchor" href="#전역-스냅숏용-동기화된-시계"></a> 전역 스냅숏용 동기화된 시계</h3>
<ul>
<li>스냅숏 격리 : 작고 빠른 읽기 쓰기 트랜잭션과 크고 오래 실행되는 읽기 전용 트랜잭션 모두를 지원해야 하는 데이터베이스에서 아주 유용한 기능
<ul>
<li>잠금을 쓰지 않고 읽기 쓰기 트랜잭션을 방해하지 않으면서 읽기 전용 트랜잭션이 특정 시점의 일관적인 상태에 있는 데이터베이스를 볼 수 있게 한다.</li>
</ul>
</li>
<li>단조 증가 Transaction ID : 스냅숏보다 나중에 쓰기가 실행 됐다면 그 내용은 스냅숏 트랜잭션 에게 보이지 않는다.</li>
<li>데이터베이스가 여러 데이터센터에 있는 여러 장비에 분산돼 있을 때는 코디네이션이 필요하므로 전역 단조 증가 트랜잭션 ID를 생성하기 어렵다.
<ul>
<li>작고 빠른 트랜잭션이 많으면 분산 시스템에서 트랜잭션 ID 생성은 방어할 수 없는 병목이 된다.</li>
<li>가장 이른 타임스탬프와 가장 늦은 타임스탬프를 포함하는 두 개의 신뢰 구간이 있고 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>=</mo><mo stretchy="false">[</mo><msub><mi>A</mi><mrow><mi>e</mi><mi>a</mi><mi>r</mi><mi>l</mi><mi>i</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub><mo separator="true">,</mo><msub><mi>A</mi><mrow><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A = [A_{earliest},A_{latest}])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mclose">)</span></span></span></span> 와 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>B</mi><mo>=</mo><mo stretchy="false">[</mo><msub><mi>B</mi><mrow><mi>e</mi><mi>a</mi><mi>r</mi><mi>l</mi><mi>i</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub><mo separator="true">,</mo><msub><mi>B</mi><mrow><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(B = [B_{earliest},B_{latest}])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mclose">)</span></span></span></span> 라는 두 구간이 겹치지 않는다면<br />
(즉 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mrow><mi>e</mi><mi>a</mi><mi>r</mi><mi>l</mi><mi>i</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub><mo>&lt;</mo><msub><mi>A</mi><mrow><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub><mo>&lt;</mo><msub><mi>B</mi><mrow><mi>e</mi><mi>a</mi><mi>r</mi><mi>l</mi><mi>i</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub><mo>&lt;</mo><msub><mi>B</mi><mrow><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A_{earliest} &lt; A_{latest} &lt; B_{earliest} &lt; B_{latest}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) B는 분명이 A보다 나중에 실행됐다. 구간이 겹칠 때만 A와 B가 어떤 순서로 실행됐는지 확신할 수 없다.</li>
</ul>
</li>
</ul>
<h3 id="프로세스-중단"><a class="markdownIt-Anchor" href="#프로세스-중단"></a> 프로세스 중단</h3>
<ul>
<li>파티션마다 리더가 하나씩 있는 데이터베이스가 있다고 가정할 때, 리더만 쓰기를 받아들이도록 허용된다면 노드가 여전히 리더인지 그리고 안전하게 쓰기를 받아들일 수 있을지 어떻게 알 수 있을까?</li>
<li>한 가지 선택은 리더가 다른 노드들로부터 임차권(lease)을 얻는 것이다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">  request = getIncomingRequest();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 항상 임차권이 적어도 10초는 남아 있게 보장한다.</span></span><br><span class="line">  <span class="keyword">if</span>(lease.expiryTimeMillis - System.currentTimeMillis() &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">    lease = lease.renew();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(lease.isValid()) &#123;</span><br><span class="line">    process(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>위 코드에서 잘못된점 : 동기화된 시계 의존, 로컬 단조 시계만 사용하도록 프로토콜을 수정하더라도 process(request) 사이 매우 짧은 시간이 흐른다고 가정한다.
<ul>
<li>쓰레드가 오랫동안 멈출 수 있다고 가정
<ul>
<li>“stop-the-world” GC</li>
<li>가상환경에서 가상장비는 서스펜드(suspend, 모든 프로세스 실행을 멈추고 메모리 내용을 디스크에 저장)됐다가 재개 될수 있다.
<ul>
<li>이 기능은 라이브 이전하는데 사용되는데, 이 경우 중단 시간의 길이는 프로세스가 메모리에 쓰는 속도에 의존한다.</li>
</ul>
</li>
<li>운영체제가 다른 스레드로 컨텍스트 스위치하거나 하이퍼바이저가 다른 가상 장비로 스위치되면 현재 실행 중인 스레드는 코드의 임의 지점에서 멈출 수 있다. 이를 스틸 타임(steal time)이라고 한다. 장비의 부하가 높으면(실행 대기 스레드의 큐가 길면) 중단 스레드가 다시 실행 되는 데 시간이 좀 걸릴 수도 있다.</li>
<li>애플리케이션이 동기식으로 디스크에 접근하면 스레드가 느린 디스크 I/O 연산이 완료되기를 기다리느라 중단될 수 있다.
<ul>
<li>ex) 자바 클래스로더는 클래스 파일이 처음 사용될 때 지연 로딩하는데, 이는 프로그램 실행 중 언제라도 일어날 수 있다.</li>
<li>심지어 I/O 중단과 GC 중단이 공모해서 지연을 결합하기도 한다.</li>
<li>디스크가 실제로는 네트워크 파일시스템이거나 네트워크 블록 장치라면 I/O 지연 시간은 네트워크 지연의 변동성에도 종속적이다.</li>
</ul>
</li>
<li>운영체제가 <em>디스크로 스왑(페이징)</em> 할 수 있게 설정됐다면 단순한 메모리 접근만 해도 페이지를 디스크에서 메모리로 로딩하게 하는 페이지 폴트가 발생할 수 있다. 이 경우 스레드는 멈춘다
<ul>
<li>메모리 압박이 높으면 이어서 다른 페이지가 디스크로 스오바될 수 있다. 극단적인 환경에서는 운영체제가 페이지를 메모리 안팎으로 스와핑하느라 대부분의 시간을 쓰고 실제 작업을 거의 못할 수 있다.</li>
<li>이를 Thrashing(스래싱)이라고 한다. 이 문제를 피하기 위해 서버 장비에서 페이징은 종종 비활성화 된다.</li>
</ul>
</li>
<li>유닉스 프로세스는 SIGSTOP 신호를 보내 멈출 수있다.</li>
</ul>
</li>
<li>이런 경우 스레드를 어떤 시점에 선점(preempt)하고 얼마간의 시간이 흐른 후 재개할 수 있다. 선점된 스레드는 이를 알아채지 못한다.</li>
<li>이 문제는 단일 장비에서 다중 스레드 코드를 스레드 안전(thread-safe)하게 만드는 것과 비슷하다. 컨텍스트 스위치가 임의로 발생할 수 있고 병렬성(parallelism)이 발생할 수도 있으므로 타이밍에 대해 어떤 가정도 할 수 없다.</li>
<li>Thread-safe
<ul>
<li>Mutex(뮤택스), Semaphore(세마포어), Atomic Counter(원자적 카운터), Lock-free(잠금 없는) data structure, blocking queue</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="fencing-token-펜싱-토큰"><a class="markdownIt-Anchor" href="#fencing-token-펜싱-토큰"></a> fencing token 펜싱 토큰</h3>
<p><img src="/images/data-intensive/chapter_8/fancing_token.png" alt="" /></p>
<ul>
<li>잠금 서버가 잠금이나 임차권을 승인할 때마다 fencing token(펜싱 토큰)도 반환한다고 가정한다. 펜싱 토큰은 잠금이 승인될 때마다 증가하는 수자다.</li>
</ul>
<h3 id="byzantine-fault-비잔틴-결함"><a class="markdownIt-Anchor" href="#byzantine-fault-비잔틴-결함"></a> Byzantine fault (비잔틴 결함)</h3>
<ul>
<li>펜싱 토큰은 부주의에 의한 오류에 빠진 노드를 감지하고 차단할 수 있다.
<ul>
<li>ex) 자신의 임차권이 만료됐다는 것을 아직 알아채지 못한 경우</li>
</ul>
</li>
<li>노드들이 신뢰성은 없지만 정직하다고 가정한다. 노드들은 결함 때문에 느리거나 결코 응답하지 않을 수 있고 그들의 상태는 뒤처질 수도 있지만 노드가 응답한다면 그 노드는 &quot;진실&quot;을 말한다고 가정한다.</li>
<li>분산 시스템 문제는 노드가 “거짓말” (임의의 결함이 있거나 오염된 응답을 보냄)을 할지도 모른다는 위험이 있다면 훨씬 더 어려워진다.
<ul>
<li>ex) 어떤 노드가 실제로는 받지 않은 특정 메세지를 받았다고 주장할 수도 있다. 이런 동작을 Byzantine fault 라고 하며 이렇게 신뢰할 수 없는 환경에서 합의에 도달하는 문제를 Byzantine Generals Problem 이라고 한다.</li>
</ul>
</li>
<li>일부 노드가 오작동하고 프로토콜을 준수하지 않거나 악의적인 공격자가 네트워크를 방해하더라도 시스템이 계속 올바르게 동작한다면 이 시스템은 Byzantine fault tolerant (비잔틴 내결함성)을 지닌다.
<ul>
<li>ex) 항공우주 산업 환경에서 컴퓨터의 메모리가 CPU 레지스터에 저장된 데이터는 방사선에 오염돼서 그 컴퓨터가 다른 노드에게 전혀 예측할 수 없는 방식으로 반응할 수 있다. 시스템 장애는 매우 비용이 크므로 비행 제어 시스템은 비잔틴 결함을 견딜 수 있어야 한다.</li>
<li>ex) 여러 조직이 참여하는 시스템에서 어떤 참여자들은 다른 사람을 속이거나 사취하려고 할지도 모른다. 이런 환경에서는 노드가 다른 노드의 메세지를 그냥 믿는 것은 안전하지 않다. 메시지 악의를 가지고 보내졌을 수 있기 때문이다. 이를테면 서로 신뢰할 수 없는 단체들이 중앙 권한에 기대지 않고 트랜잭션이 발생했는지 아닌지를 판단하는 방법으로 비트코인(Bitcoin)이나 다른 블록체인 같은 Peer to Peer 네트워크를 고려할 수 있다.</li>
</ul>
</li>
<li>웹 애플리케이션은 최종 사용자가 제어하는 웹브라우저 같은 클라이언트 행동이 임의적이고 악의적이라고 예상해야 한다.
<ul>
<li>input validation(입력 확인), sanitization(살균), output escaping(출력 이스케이핑)이 매우 중요한 이유다.</li>
<li>SQL injection(SQL 주입 공격)과 Cross Site Scripting(크로스 사이트 스크립팅) 을 막야아한다.</li>
</ul>
</li>
</ul>
<h3 id="약한-형태의-거짓말"><a class="markdownIt-Anchor" href="#약한-형태의-거짓말"></a> 약한 형태의 거짓말</h3>
<ul>
<li>노드들이 일반적으로 정직하다고 가정하지만 약한 형태의 “거짓말” (예를 들어 하드웨어 문제, 소프트웨어 버그, 잘못된 설정 때문에 유효하지 않는 메시지)로부터 보호해주는 메커니즘을 소프트웨어에 추가하는게 가치가 있을수도 있다.
<ul>
<li>네트워크 패킷은 때때로 하드웨어 문제나 운영체제, 드라이버, 라우터 등의 버그 때문에 오염된다. 보통 오염된 패킷은 TCP와 UDP에 내장된 체크섬으로 검출되지만 때로는 검출을 피하는 경우도 있다. 이런 오염으로부터 보호하려면 보통 애플리케이션 수준 프로토콜에서 체크섬을 쓰는 것처럼 단순한 수단을 쓰면 충분하다.</li>
<li>공개적으로 접근 가능한 애플리케이션은 사용자 입력을 신중하게 살균해야 한다.
<ul>
<li>ex) 값이 합당한 범위에 속하는지 확인하고 메모리를 대량으로 할당해서 서비스 거부가 발생하지 않도록 문자열의 크기를 제한해야 한다.</li>
<li>ex) 방화벽 뒤에 있는 내부 서비스는 입력 확인을 덜 엄격하게 할 수도 있겠지만 입력값에 대해 기본적인 sanity-checking(정상성 점검)을 하는게 좋다.</li>
</ul>
</li>
<li>NTP 클라이언트는 여러 서버 주소를 설정할 수 있다. 동기화를 할 때 클라이언트는 모든 서버에 접속해서 그들의 오차를 수정한 후 서버 중 다수가 어떤 시간 범위에 동의하는지 확인할 수 있다.대다수의 서버들이 정상이기만 하면 잘못된 시간을 보고하는 잘못 설정된 NTP 서버를 이상치로 검출해서 동기화 대상에서 제거할 수 있다. NTP에 여러 서버를 사용하면 서버 한 대를 쓸 때보다 견고해진다.</li>
</ul>
</li>
</ul>
<h3 id="시스템-모델과-현실"><a class="markdownIt-Anchor" href="#시스템-모델과-현실"></a> 시스템 모델과 현실</h3>
<ul>
<li>동기식 모델
<ul>
<li>동기식 모델은 네트워크 지연, 프로세스 중단, 시계 오차에 모두 제한이 있다고 가정한다. 시계가 정확하게 동기화된다거나 네트워크 지연이 없다고 암시하는 것은 아니다.</li>
<li>네트워크 지연, 중단, 시계 드리프트가 결고 어떤 고정된 상한치를 초과하지 않는 것임을 안다는 것 뿐이다.</li>
<li>동기식 모델은 기약 없는 지연과 현실 시스템 대부분에서 현실적인 모델이 아니다.</li>
</ul>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/09/28/designing-data-intensive-application-7/">designing-data-intensive-application-7</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-28</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/transaction/">transaction</a></span><div class="content"><h3 id="현실세계-문제점"><a class="markdownIt-Anchor" href="#현실세계-문제점"></a> 현실세계 문제점</h3>
<ul>
<li>데이터베이스 소프트웨어나 하드웨어는 언제라도 실패할 수 있다.</li>
<li>애플리케이션은 언제라도 죽을 수 있다.</li>
<li>네트워크가 끊기면 애플리케이션과 데이터베이스의 연결이 갑자기 끊기거나 데이터베이스 노드 사이의 통신이 안 될 수 있다.</li>
<li>여러 클라이언트가 동시에 데이터베이스에 쓰기를 실행해서 다른 클라이언트가 쓴 내용을 덮어쓸 수 있다.</li>
<li>클라이언트가 부분적으로만 갱신돼서 비정상적인 데이터를 읽을 수 있다.</li>
<li>클라이언트 사이의 경쟁 조건은 예측하지 못한 버그를 유발할 수 있다.</li>
</ul>
<h3 id="transaction-mechanism"><a class="markdownIt-Anchor" href="#transaction-mechanism"></a> Transaction mechanism</h3>
<ul>
<li>애플리케이션에서 몇 개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법이다.</li>
<li>개념적으로 한 트랜잭션 내의 모든 읽기와 쓰기는 한 연산으로 실행된다.</li>
<li>트랜잭션은 전체가 성공하거나 실패한다.</li>
</ul>
<h3 id="acid"><a class="markdownIt-Anchor" href="#acid"></a> ACID</h3>
<ul>
<li>테오 하더(Theo Harder), 안드레아스 로이터(Andreas Reuter)는 데이터 베이스에서 내결함성 메커니즘을 나타내는 용어를 확립했다.</li>
<li>Atomicity(원자성)</li>
<li>Consistency(일관성)</li>
<li>Isolation(격리성)</li>
<li>Durability(지속성)</li>
<li>그러나 현실에서는 데이터베이스마다 ACID구현이 제각각이다.</li>
<li>ACID compliant 한다고 할때 그 시스템에서 실제로 어떤 것을 기대할 수 있는지 분명하지 않다. (ACID 표준을 따르지 않는 시스템은 때로 BASE라고 불린다.)
<ul>
<li>Basically Available</li>
<li>Atomicity</li>
<li>Soft state</li>
<li>Eventual Consistency</li>
</ul>
</li>
</ul>
<h3 id="atomicity"><a class="markdownIt-Anchor" href="#atomicity"></a> Atomicity</h3>
<ul>
<li>일반적으로 원자적이란 더 작은 부분으로 쪼갤 수 없는 뭔가를 가리킨다.
<ul>
<li>시스템은 연산을 실행하기 전이나 실행한 후의 상태에만 있을 수 있으며 그 중간 상태에는 머물수 없다.</li>
<li>ACID의 맥락에서 보면 원자성은 동시성과 관련이 없다.</li>
<li>여러 쓰기 작업이 하나의 원자적 인 트랜잭션으로 묶여 있는데 결함 때문에 왼료(커밋)될 수 없다면 어보트되고<br />
데이터베이스는 이 트랜잭션에서 지금끼지 실행한 쓰기를 무시하거나 취소해야 한다.</li>
<li>어보트 능력 (abortability)이 원자성 보다 나은 단어겠지만 원자성이 자주 쓰이므로 이 단어를 계속 사용하겠다.</li>
</ul>
</li>
</ul>
<h3 id="consistency"><a class="markdownIt-Anchor" href="#consistency"></a> Consistency</h3>
<ul>
<li>유감스럽게도 같은 단어가 최소 네가지 의미로 쓰이고 있다.</li>
<li>복제 일관성(replica consistency)과 비동기식으로 복제되는 시스템에서 발생하는 최종적 일관성(eventualconsistency) 문제에 대해 설명했다</li>
<li>일관성 해싱은 어떤 시스템들에서 재균형화를 위해 사용하는 파티셔닝방법이다.</li>
<li>CAP 정리(9장 침고)에서 일관성이란 닫어는 선형성(Iinearizability)을 의미한다</li>
<li>ACID의 맥락에서 일관성은 데이터베이스가 “좋은 상태”에 있어야 한다는 것의 애플리케이션에 특화된 개념을 가리킨다，</li>
<li>데이터에 관한 어떤 선언 (불변식 {invariant})이 있다는 것이다.</li>
</ul>
<h3 id="isolation"><a class="markdownIt-Anchor" href="#isolation"></a> Isolation</h3>
<p><img src="/images/data-intensive/chapter_7/transaction_isolation.png" alt="" /></p>
<ul>
<li>격리성은 동시에 실행되는 트랜잭션은 서로 격리된다는 것을 의미한다.</li>
<li>데이터베이스는 실제로는 여러 트랜잭션이 동시에 실행됐더라도 트랜잭션이 커밋됐을 때의 결과가 트랜잭션이 순차적으로 실행됐을 때의 결과와 동일하도록 보장한다.</li>
<li>직렬성 격리(serializable isolation)는 성능 손해를 동반하므로 현실에서는 거의 시용되지 않는다.</li>
</ul>
<h3 id="durability"><a class="markdownIt-Anchor" href="#durability"></a> durability</h3>
<ul>
<li>트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장이다.</li>
</ul>
<h3 id="다중-객체-트랜잭션의-필요성"><a class="markdownIt-Anchor" href="#다중-객체-트랜잭션의-필요성"></a> 다중 객체 트랜잭션의 필요성</h3>
<h3 id="read-commited"><a class="markdownIt-Anchor" href="#read-commited"></a> read commited</h3>
<ul>
<li>데이터베이스에서 읽을 때 커밋된 데이터만 보게 된다(더티 읽기가 없음)</li>
<li>데이터베이스에서 쓸 때 커밋된 데이터만 덮어쓰게 된다(더티 쓰기가 없음)</li>
</ul>
<h3 id="더티-읽기-방지"><a class="markdownIt-Anchor" href="#더티-읽기-방지"></a> 더티 읽기 방지</h3>
<p><img src="/images/data-intensive/chapter_7/prevent_dirty_read.png" alt="" /></p>
<ul>
<li>트랜잭션이 여러 객체를 갱신하는데 더티 읽기가 생기면 다른 트랜잭션이 일부는 갱신된 값을， 일부는 갱신되지 않은 값을 볼수있다</li>
<li>트랜잭션이 어보트되면 그때까지 쓴 내용은 모두 롤백돼야 한다. 데이터베이스가 더티 읽기를 허용하면 트랜잭션이 나중에 롤백될 데이터，<br />
즉 실제로는 데이터베이스에 결코 커멋되지 않을 데이터를 볼 수 있다 그 결과를 따져보려 하면 곧 머리가 흔란스러워질 것이다.</li>
</ul>
<h3 id="더티-쓰기-방지"><a class="markdownIt-Anchor" href="#더티-쓰기-방지"></a> 더티 쓰기 방지</h3>
<ul>
<li>먼저 쓴 내용이 아직 커잇되지 않은 트랜잭션에서 쓴 것이고 니중에 실행된 쓰기 작업이 커밋되지 않은 값을 덮어써버리면 어떻게 될까?</li>
</ul>
<h3 id="snapshot-isolation"><a class="markdownIt-Anchor" href="#snapshot-isolation"></a> SnapShot Isolation</h3>
<ul>
<li>읽는 쪽에서 쓰는 쪽을 결코 차단하지 않고 쓰는 쪽에서 읽는 쪽을 결코 차단하지 않는다는 것</li>
<li>MVCC(multi-version concurrency control)</li>
<li>오라클에서는 직렬성, Postgresql, mysql에서는 repeatable read라고 한다.</li>
</ul>
<h3 id="원자적-쓰기-연산"><a class="markdownIt-Anchor" href="#원자적-쓰기-연산"></a> 원자적 쓰기 연산</h3>
<ul>
<li>커서 안정성(cursor stability) : 보통 객체를 읽을 때 그 객체에 독점적인(exclusive) 잠금을 획득해 구현하며 갱신이 적용될 때 까지 다른 트랜잭션에서 해당 객체를 읽지 못하게 한다.</li>
<li>명시적 잠금 : ex) BEGIN TRANSACTION</li>
<li>갱신 손실 자동 감지 : read-modify-write 주기가 순차적으로 실행되도록 강제함으로써 갱신 손실을 방지하는 방법이다.
<ul>
<li>관리자가 갱신 손실을 발견하면 트랜잭션을 어보트 시키고 주기를 재시도하도록 강제하는 방법
<ul>
<li>장점 : snapshot isolation 과 결합해 효율적으로 수행이 가능</li>
</ul>
</li>
</ul>
</li>
<li>Compare-and-set : 마지막으로 읽은 후로 변경되지 않았을 때만 갱신을 허용함으로써 갱신 손실을 회피하는 것이다. 현재 값이 이전에 읽은 값과 일치하지 않으면 갱신은 반영되지 않고 주기를 재시도한다.</li>
<li>최종 쓰기 승리 : 갱신 손실이 발생하기 쉽다.</li>
</ul>
<h3 id="쓰기-스큐와-팬텀"><a class="markdownIt-Anchor" href="#쓰기-스큐와-팬텀"></a> 쓰기 스큐와 팬텀</h3>
<ul>
<li>write skew :  <img src="/images/data-intensive/chapter_7/write_skew.png" alt="" /></li>
</ul>
<ol>
<li>select 질의가 어떤 검색 조건에 부합하는 로우를 검색함으로써 어떤 요구사항을 만족하는지 확인한다.</li>
<li>첫 번째 질의의 결과에 따라 애플리케이션 코드는 어떻게 진행할지(해당 연산을 계속 처리할지 사용자에게 오류를 보고하고 중단할지) 결정한다.</li>
<li>어플리케이션이 계속 처리하기로 결정했다면 데이터베이스에 쓰고(Insert, Update, Delete) 트랜잭션을 커밋한다.
<ul>
<li>이 쓰기의 효과로 2단계를 결정한 전제 조건이 바뀐다. 다시 말해 쓰기를 커밋한 후 1단계의 SELECT 질의를 재실행하면 다른 결과를 얻게 된다.<br />
쓰기의 결과로 검색 조건에 부합하는 로우 집합이 바뀌었기 때문이다.
<ul>
<li>호출 대기하는 의사가 한 명 줄었다.</li>
<li>해당 시간에 회의실이 예약됐다.</li>
<li>옮겨진 물체가 게임판의 특정 위치를 차지했다.</li>
<li>사용자명이 점유됐다.</li>
<li>계좌에 남은 돈이 줄었다.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>팬텀(phantom) : 어떤 트랜잭션에서 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과</li>
</ul>
<h3 id="직렬성"><a class="markdownIt-Anchor" href="#직렬성"></a> 직렬성</h3>
<ul>
<li>격리 수준은 이해하기 어렵고 데이터베이스마다 그 구현에 일관성이 없다.</li>
<li>애플리케이션 코드를 보고 특정한 격리 수준에서 해당 코드를 실행하는 게 안전한지 알기 어렵다. 특히 동시에 일어나는 모든 일을 알지 못할 수도 있는 거대한 애플리케이션이라면 더 그렇다.</li>
<li>경쟁 조건을 감지하는 데 도움이 되는 좋은 도구가 없다. 이론상으로는 정적 분석이 도움될지 모르지만 아직 현실적으로 사용되는 연구 기법은 없다. 동시성 문제는 보통 비결정적이라서 테스트하기 어렵다. 타이밍이 좋지 못할 때만 문제가 발생한다.</li>
<li>직렬성 격리를 사용하라!</li>
</ul>
<h4 id="실제적인-직렬실행"><a class="markdownIt-Anchor" href="#실제적인-직렬실행"></a> 실제적인 직렬실행</h4>
<ul>
<li>모든 트랜잭션은 작고 빨라야 한다. 느린 트랜잭션 하나가 모든 트랜잭션 처리를 지연시킬 수 있기 때문이다.</li>
<li>활성화된 데이터셋이 메모리에 적재될 수 있는 경우로 사용이 제한된다.</li>
<li>쓰기 처리량이 단일 CPU코어에서 처리할 수 있을 정도로 충분히 낮아야 한다. 그렇지 않으면 여러 파티션에 걸친 코디네이션이 필요하지 않도록 트랜잭션을 파티셔닝 해야 한다.</li>
<li>여러 파티션에 걸친 트랜잭션도 쓸 수 있지만 이것을 사용할 수 있는 정도에는 엄격한 제한이 있다.</li>
</ul>
<h4 id="2단계-잠금-two-phase-locking"><a class="markdownIt-Anchor" href="#2단계-잠금-two-phase-locking"></a> 2단계 잠금 (two-phase locking)</h4>
<ul>
<li>mysql(innoDB), SQL 서버 직렬성 격리 수준 구현, DB2 반복 읽기 격리 수준</li>
<li>읽는 쪽과 쓰는 쪽을 막는것은 데이터베이스의 각 객체에 잠금을 사용 (shared 공유, exclusive 독점)
<ul>
<li>트랜잭션이 객체를 읽기 원한다면 공유 모드로 잠금을 획득 해야 함. 동시에 여러 트랜잭션이 공유 모드로 잠금을 획득하는 것은 허용되지만, 독점 모드로 잠금을 획득한 트랜잭션이 있다면 이 트랜잭션이 완료 될때까지 기다려야 함</li>
<li>트랜잭션이 객체에 쓰기를 원한다면 독점 모드로 잠금을 획득 해야 함. 어떤 트랜잭션도 동시에 잠금을 획득할 수 없기 때문에 잠금이 존재하면 대기한다.</li>
<li>트랜잭션에 객체를 읽다가 쓰기를 실행 할때는 공유 -&gt; 독점 잠금으로 업그레이드 해야햔다.</li>
<li>트랜잭션이 잠금을 획득한 후에는 트랜잭션이 종료될때 까지 잠금을 갖고 있어야 한다. 2단계 : 획득, 해제</li>
</ul>
</li>
<li>Dead Lock이 빈번하게 일어나기 때문에 데이터베이스는 트랜잭션 사이의 교착 상태를 자동으로 감지하고 하나를 어보트 시켜 다른 트랜잭션들이 진행할 수 있게 한다.</li>
<li>색인 범위 잠금(index-range locking), 다음키 잠금(Next-key locking)</li>
<li>범위 잠금을 잡을 수 있는 적합한 색인이 없다면 데이터베이스는 테이블 전체에 공유 잠금을 잡는 것으로 대체 할 수 있다.</li>
</ul>
<h4 id="직렬성-스냅숏-격리serializable-snapshot-isolation"><a class="markdownIt-Anchor" href="#직렬성-스냅숏-격리serializable-snapshot-isolation"></a> 직렬성 스냅숏 격리(Serializable snapshot isolation)</h4>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/09/14/designing-data-intensive-application-5/">designing-data-intensive-application-5</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-14</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/shared-data/">shared data</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/replication/">replication</a></span><div class="content"><h2 id="replication"><a class="markdownIt-Anchor" href="#replication"></a> Replication</h2>
<ul>
<li>Single Leader Replication</li>
<li>Multi Leader Replication</li>
<li>LeaderLess Replication</li>
</ul>
<h3 id="leader-follower"><a class="markdownIt-Anchor" href="#leader-follower"></a> Leader &amp; Follower</h3>
<ul>
<li>
<p>Replica : 복제 서버</p>
<ul>
<li>모든 복제 서버에 모든 데이터가 있다는 사실을 어떻게 보장하는가?
<ul>
<li>Leader-Based replication (active/passive, master/slave) : 복제 서버 중 하나를 리더로 지정하고, 리더는 로컬 저장소에 새로운 데이터를 기록<br />
복제 서버는 팔로워(follower)라고 한다. 리더가 로컬 저장소에 새로운 데이터를 기록할 때마다 데이터 변경을 Replication Log or Change Stream의 일부로 팔로워에게 전송<br />
각 팔로워가 리더로부터 로그를 받으면 리더가 처리한 것과 동일한 순서로 모든 쓰기를 적용해 복사본을 갱신한다.<br />
<img src="/images/data-intensive/chapter_5/replication_copy.png" alt="" /></li>
</ul>
</li>
</ul>
</li>
<li>
<p>동기식 대 비동기식 복제</p>
<ul>
<li>동기식 : 팔로워가 리더와 일관성 있게 최신 복사본을 가지는 것을 보장, Block 때문에 처리 대기 시간 발생
<ul>
<li>현실적으로 데이터베이스에서 동기식 복제를 사용하려면 보통 팔로워 하나는 동기식으로 하고 그 밖에는 비동기식으로 하는 것을 의미</li>
<li>적어도 두 노드에 데이터의 최신 복사본이 있는 것을 보장한다. 이것을 semi-synchronous(반동기식)이라 한다.</li>
</ul>
</li>
<li>비동기식 : 리더 기반 복제는 완전히 비동기식으로 구성한다. 리더가 잘못되고 복구할 수 없으면 팔로워에 아직 복제되지 않은 모든 쓰기는 유실된다.</li>
</ul>
</li>
</ul>
<h3 id="follower-failover"><a class="markdownIt-Anchor" href="#follower-failover"></a> Follower failover</h3>
<ul>
<li>각 팔로워는 리더로부터 수신한 데이터 변경 로그를 로컬 디스크에 보관</li>
<li>팔로워는 리더에 연결해 팔로워 연결이 끊어진 동안 발생한 데이터 변경을 모두 요청</li>
</ul>
<h3 id="leader-failover"><a class="markdownIt-Anchor" href="#leader-failover"></a> Leader failover</h3>
<ul>
<li>팔로워 중 하나를 새로운 리더로 승격 &amp; 다른 팔로워는 새로운 리더로부터 데이터 변경을 읽어오기 시작해야한다.</li>
<li>자동 장애 복구
<ul>
<li>리더 장애 판단 : 보통 타임아웃으로 체크</li>
<li>새로운 리더 선택 : 보통 이전 리더의 최신 데이터 변경사항을 가진 Follower중에서 선출</li>
<li>새로운 리더 사용을 위해 시스템을 재설정</li>
</ul>
</li>
<li>자동 장애 복구 시 실패 Case
<ul>
<li>비동기식 복제를 사용하면 새로운 리더는 이전 리더가 실패하기 전 이전 리더의 쓰기를 일부 수신하지 못할 수 있다.</li>
<li>Out of date Follower Leader 선출 문제</li>
<li>특정 결함 시나리오 (Split Brain : 두 노드가 모두 자신이 리더라고 믿을 수 있다.)</li>
<li>리더가 분명히 죽었다고 판단 가능한 적절한 타임아웃은 얼마인가?</li>
</ul>
</li>
</ul>
<h3 id="convergent"><a class="markdownIt-Anchor" href="#convergent"></a> Convergent</h3>
<ul>
<li>각쓰기에 고유 ID를 가진 쓰기를 고르고 타임스탬프를 사용하는 경우를</li>
</ul>
<h3 id="version-vector"><a class="markdownIt-Anchor" href="#version-vector"></a> Version Vector</h3>
<p><a href="https://en.wikipedia.org/wiki/Version_vector" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Version_vector</a></p>
<h3 id="다이나모-스타일"><a class="markdownIt-Anchor" href="#다이나모-스타일"></a> 다이나모 스타일</h3>
<ul>
<li>리더 없는 복제 모델의 오픈소스 데이터스토어
<ul>
<li>읽기 복구 : 클라이언트가 여러 노드에서 병렬로 읽기를 수행하면 오래된 응답을 감지</li>
<li>안티 엔트로피 처리 : 일부 데이터 스토어는 백그라운드 프로세스를 두고 복제 서버 간 데이터 차이를 지속적으로 찾아<br />
누락된 데이터를 하나의 복제 서버에서 다른 서버로 복사</li>
</ul>
</li>
</ul>
<h3 id="동시-쓰기-감지"><a class="markdownIt-Anchor" href="#동시-쓰기-감지"></a> 동시 쓰기 감지</h3>
<ul>
<li>읽기 요청을 병렬로 여러 노드에 전달</li>
</ul>
<h3 id="읽기와-쓰기를-위한-정족수"><a class="markdownIt-Anchor" href="#읽기와-쓰기를-위한-정족수"></a> 읽기와 쓰기를 위한 정족수</h3>
<ul>
<li>n개의 복제 서버가 있을 때 모든 쓰기는 w개의 노드에서 성공해야 쓰기가 확정되고 모든 읽기는 최소한 r개의 노드에 질의해야 한다.</li>
<li>w = r = (n+1)/2 로 설정</li>
<li>w + r &gt; n 이면 다음과 같이 사용 불가능한 노드를 용인한다.
<ul>
<li>w &lt; n 이면 노드 하나를 사용할 수 없어도 여전히 쓰기를 처리할 수 있다.</li>
<li>r &lt; n 이면 노드 하나를 사용할 수 없어도 여진히 읽기를 처리할 수 있다.</li>
<li>n = 3, w = 2, r = 2이면 사용 불가능한 노드 하나를 용인한다.</li>
<li>n = 5, w = 3, r = 3이면 사용 불가능한 노드 두개를 용인한다.</li>
</ul>
</li>
</ul>
<p><img src="/images/data-intensive/chapter_5/quorum_consistency.png" alt="" /></p>
<h3 id="최종-쓰기-승리동시-쓰기-버리기-last-write-wins-element-set"><a class="markdownIt-Anchor" href="#최종-쓰기-승리동시-쓰기-버리기-last-write-wins-element-set"></a> 최종 쓰기 승리(동시 쓰기 버리기) : Last-Write-Wins-Element-Set</h3>
<ul>
<li>LWW로 데이터베이스를 안전하게 사용하는 유일한 방법은 키를 한번만 쓰고 이후에는 불변값으로 다루는 것이다.<br />
이 방법은 같은 키를 동시에 갱신하는 상황을 방지한다. 예를 들어, 카산드라를 사용할 때 추천하는 방법은 키로 UUID를 사용해 모든 쓰기 작업에 고유한 키를 부여하는 것이다.</li>
</ul>
<h3 id="이전-발생-관계와-동시성-happens-before"><a class="markdownIt-Anchor" href="#이전-발생-관계와-동시성-happens-before"></a> “이전 발생” 관계와 동시성 : Happens-before</h3>
<ul>
<li>Causally dependent : 인과성이 있다.</li>
<li>작업이 다른 작업보다 먼저 발생하지 않으면 (즉 어느 작업도 다른 작업에 대해 알지 못한다면) 단순히 동시 작업이라 말한다.</li>
</ul>
<h3 id="복제"><a class="markdownIt-Anchor" href="#복제"></a> 복제</h3>
<ul>
<li>단일리더복제
<ul>
<li>클라이언트는 모든 쓰기를 단일 노드(리더)로 전송하고 리더는 데이터 변경 이벤트 스트림을 다른 복제 서버(말로워)로 전송 한다. 읽기는 모든 복제 서버가 수행할 수 있지만 팔로원의 읽기는 오래된 값일 수 있다</li>
</ul>
</li>
<li>다중리더복제
<ul>
<li>클라이언트는 각 쓰기를 여러 리더 노드 중 쓰기를 맡l’üf들일 수 있는 노드로 전송한다 리더는 데이터 변경 이벤트 스트림을 다른 리더와 모든 딸로워 노도로 전송한다</li>
</ul>
</li>
<li>리더없는복제
<ul>
<li>클라이언트는 각 쓰기를 여러 노드로 전송한다. 클라이언트는 오래된 데이터를 감지하고 이를 바로잡기 위해 병렬로 여러 노 드에서읽는다</li>
</ul>
</li>
</ul>
<h3 id="주의"><a class="markdownIt-Anchor" href="#주의"></a> 주의</h3>
<ul>
<li>쓰기 후 읽기 일관성
<ul>
<li>시용자는 자신이 저|출한 데이터를 항상볼 수 있어야 한다</li>
</ul>
</li>
<li>단조 읽기
<ul>
<li>사용자가 어떤 시점에 데이터를 본 후에는 예전 시점의 데이터는 나중에 볼 수 없다</li>
</ul>
</li>
<li>일관된 순서로 읽기
<ul>
<li>사용자는 인과성이 있는 상태의 데이터 를 봐야 한다 예를 들어 질문과 그에 대한 답을 순서에 맞게 봐야한다.</li>
</ul>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/09/14/designing-data-intensive-application-6/">designing-data-intensive-application-6</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-14</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/partitioning/">partitioning</a></span><div class="content"><h3 id="partitioning"><a class="markdownIt-Anchor" href="#partitioning"></a> partitioning</h3>
<ul>
<li>Sharding
<ul>
<li>데이터 파티셔닝을 원히는 주된 이유는 확장성이다</li>
</ul>
</li>
</ul>
<h3 id="키-값데이터파티셔닝"><a class="markdownIt-Anchor" href="#키-값데이터파티셔닝"></a> 키-값데이터파티셔닝</h3>
<ul>
<li>파티셔닝이 고르게 이뤄지지 않이- 다른 파티션보다 데이터가 많거 나 질의를 많이 받는 파티션이 있 다면 쏠렸다(skewed)고 말한다.</li>
<li>불균형하게 부하가 높은 파티션을 핫스팟이라고 힌다.</li>
</ul>
<h3 id="키-범위-기준-파티셔닝"><a class="markdownIt-Anchor" href="#키-범위-기준-파티셔닝"></a> 키 범위 기준 파티셔닝</h3>
<ul>
<li>파티셔닝하는 방법 중 하나는 종이 백과사전처럼(그림 6-2) 각 파티션에 연속된 범위(어떤 최솟값 에서 최뱃값까지)의 키를 할당하는 것이다.<br />
<img src="/images/data-intensive/chapter_6/key_range_based_partitioning.png" alt="" /></li>
<li>장점
<ul>
<li>키를 정렬된 순서로 저장할 수 있다.</li>
</ul>
</li>
<li>단점
<ul>
<li>키 범위 기준파티셔닝은 특정한 접근패턴이 핫스핏을 유발</li>
</ul>
</li>
</ul>
<h3 id="키의-해시값-기준-파티셔닝"><a class="markdownIt-Anchor" href="#키의-해시값-기준-파티셔닝"></a> 키의 해시값 기준 파티셔닝</h3>
<ul>
<li>파티셔닝용 해시 함수는 암호적으로 강력할 필요는 없다.
<ul>
<li>카산드라, 몽고DB : MD5</li>
<li>볼드모트 : 파울러 놀 보 (Fowler-Noll-Vo)</li>
</ul>
</li>
<li>장점
<ul>
<li>키를 파티션 사이에 균일하게 분산시키는데 좋다</li>
</ul>
</li>
<li>단점
<ul>
<li>범위 질의를 효율적으로 실행할 수 있는 능력이 부족하다.</li>
</ul>
</li>
<li>카산드라는 테이블을 선언할 때 여러 칼럼을 포함하는 복합 기본키를 지정해 SS테이블에서 데이터를 정렬하는 연쇄된 색인으로 사용한다.</li>
</ul>
<h3 id="쏠린-작업부하와-핫스팟-완화"><a class="markdownIt-Anchor" href="#쏠린-작업부하와-핫스팟-완화"></a> 쏠린 작업부하와 핫스팟 완화</h3>
<ul>
<li>항상 동일한 키를 읽고 쓰는 극단적인 상황에서는 모든 요청이 동일한 파티션으로 쏠리게 된다.</li>
</ul>
<h3 id="파티셔닝과-보조-색인"><a class="markdownIt-Anchor" href="#파티셔닝과-보조-색인"></a> 파티셔닝과 보조 색인</h3>
<ul>
<li>지금까지 설명한 파티셔닝 방식은 키-값 데이터 모델에 의존한다.</li>
<li>보조 색인은 관계형 데이터베이스의 핵심 요소이며 문서 데이터베이스에서도 흔하다.</li>
</ul>
<h3 id="문서-기준-보조-색인-파티셔닝"><a class="markdownIt-Anchor" href="#문서-기준-보조-색인-파티셔닝"></a> 문서 기준 보조 색인 파티셔닝</h3>
<ul>
<li>
<p>각 항목에는 문서 ID라고 불리는 고유 ID가 존재한다.<br />
<img src="/images/data-intensive/chapter_6/document_based_sub_index_partitioning.png" alt="" /></p>
</li>
<li>
<p>지역 색인(Local Index)이라고도 한다.</p>
</li>
<li>
<p>문서ID에 뭔가 특별한 작업을 하지 않는다면 동일 파티션에 저장되리라는 보장이 없기 때문에 모든 파티션으로 질의를 보내 얻은 결과를 모두 보아야 한다.</p>
</li>
<li>
<p>스캐터/개더(scatter/gather)라고 한다.</p>
</li>
</ul>
<h3 id="용어-기준-보조-색인-파티셔닝"><a class="markdownIt-Anchor" href="#용어-기준-보조-색인-파티셔닝"></a> 용어 기준 보조 색인 파티셔닝</h3>
<ul>
<li>term-partitioning : 용어(문서에 등장하는 모든 단) 기준 파티셔닝<br />
<img src="/images/data-intensive/chapter_6/term_based_sub_index_partitioning.png" alt="" /></li>
</ul>
<h3 id="파티션-재균형화"><a class="markdownIt-Anchor" href="#파티션-재균형화"></a> 파티션 재균형화</h3>
<ul>
<li>질의 처리랑이 증가해서 늘어난 부하를 처리하기 위해 CPU를 더 추가하고 싶다.</li>
<li>데이터셋 크기가 증가해서 데이터셋 저장에 시용할 디스크와 램을 추가하고 싶다.</li>
<li>장비에 장애가 발생해서 그 장비가 담당하던 역할을 다른 서버가 넘겨받아야 한다.</li>
<li>재균형화 : 클러스터에서 한 노드가 담당하던 부하를 다른 노드로 옮기는 과정을 재균형화(rebalancing)이라고 한다.
<ul>
<li>재균형화 후, 부하(데이터저장소, 읽기 쓰기 요청)가 클러스터 내에 있는 노드들 사이에 균등하게 분배돼야 한다.</li>
<li>재균형화 도중에도 데이터베이스는 읽기 쓰기 요청을 받아들여야 한다</li>
<li>재균형화가 빨리 실행되고 네트워크와 디스크 I/0 부하를 최소화할 수 있도록 노드들 사이에 데이터가 필요 이상으로 옮겨 져서는 안된다</li>
</ul>
</li>
</ul>
<h3 id="재균형화-전략"><a class="markdownIt-Anchor" href="#재균형화-전략"></a> 재균형화 전략</h3>
<ul>
<li>쓰면 안되는 방법 : 해시값에 모드 N 연산을 실행
<ul>
<li>재균형화 비용이 지나지체 커진다.</li>
</ul>
</li>
</ul>
<h3 id="파티션-개수-고정"><a class="markdownIt-Anchor" href="#파티션-개수-고정"></a> 파티션 개수 고정</h3>
<ul>
<li>클러스터에 노드가 추가되면 새 노드는 파티션이 다시 균일하게 분배될 때까지 기존 노드에서 파티션 몇개를 가져올 수 있다.</li>
<li>파티션은 노드 사이에서 통째로 이동하기만 하며, 파티션의 개수는 바뀌지 않고 파티션에 할당된 키도 변경되지 않는다.</li>
<li>이러한 재균형화 방법은 엘라스틱 서치에 쓰인다.</li>
<li>이 방식을 사용할 때는 보통 데이터베이스가 처음 구축될 때 파티션 개수가 고정되고 이후에 변하지 않는다.<br />
이론적으로는 파티션을 쪼개거나 합치는게 가능하지만 파티션 개수가 고정되면 운영이 단순화되어 고정 파티션을 사용하는 데이터베이스는 파티션 분할을 지원하지 않는다.<br />
<img src="/images/data-intensive/chapter_6/fixed_partition_node.png" alt="" /></li>
</ul>
<h3 id="동적-파티셔닝"><a class="markdownIt-Anchor" href="#동적-파티셔닝"></a> 동적 파티셔닝</h3>
<ul>
<li>HBase, Rsync DB
<ul>
<li>파티션 크기가 설정된 값을 넘어서면 (HBase에서는 10GB가 Default) 파티션을 두개로 쪼개 각각에 원래 파티션의 절반 정도의 데이터가 포함되게 한다.</li>
<li>반대로 데이터가 많이 삭제되어 파티션 크기가 임계값 아래로 떨어지면 인접한 파티션과 합쳐질 수 있다.</li>
<li>HBase의 경우 HDFS를 통해 파티션 파일이 전송된다.</li>
<li>빈 데이터베이스는 파티션 경계를 정하기에 사전정보가 부족하다. 이를 보완하기 위해 HBase와 몽고DB에서는 빈 데이터베이스에 초기 파티션 집합을 설정할 수 있게 Pre-splitting을 할 수 있게 한다.</li>
</ul>
</li>
</ul>
<h3 id="노드-비례-파티셔닝"><a class="markdownIt-Anchor" href="#노드-비례-파티셔닝"></a> 노드 비례 파티셔닝</h3>
<ul>
<li>Cassandra or Ketama : 파티션 개수가 노드 대수에 비례하게 하는 것</li>
<li>노드 대수가 변함 없는 동안은 개별 파티션 크기가 데이터셋 크기에 비례해서 증가하지만 노드 대수를 늘리면 파티션 크기는 다시 작아진다.</li>
<li>새 노드가 클러스터에 추가되면 고정된 개수의 파티션을 무작위로 선택해 분할하고 각 분할된 파티션의 절반은 그대로 두고 다른 절반은 새 노드에 할당한다.</li>
<li>파티션 경계를 무작위로 선택하려면 해시 기반 파티셔닝을 사용해야 한다. 실제로 이 방법은 일관성 해싱의 원래 정의에 가장 가깝게 대응한다.</li>
<li>최근에 나온 해시 함수를 쓰면 메타데이터 오버헤드를 낮추면서도 비슷한 효과를 얻을 수 있다.</li>
</ul>
<h3 id="운영-자동-재균형화와-수동-재균형화"><a class="markdownIt-Anchor" href="#운영-자동-재균형화와-수동-재균형화"></a> 운영: 자동 재균형화와 수동 재균형화</h3>
<ul>
<li>완전 자동 재균형화 : 관리자의 개입이 전혀 없이 시스탬이 지동으로 언제 파티션을 노드 사이에 이 동할지 결정함</li>
<li>완전 수동 재균형화 : 관리자가 명시적으로 파티션을 노드에 할당하도록 설정하고 관리자가 재설정할 때만 파티션 할당이 변경됨</li>
</ul>
<h3 id="요청-라우팅"><a class="markdownIt-Anchor" href="#요청-라우팅"></a> 요청 라우팅</h3>
<ul>
<li>Service Discovery
<ul>
<li>네트워크를 통해 접속되는 소프트웨어라면 어떤 것이든지, 특히 고가용성을 지향하는 소프웨어라면 모두 이 문제가 있다.</li>
<li>여러 회사에서 자체 서비스 찾기 도구를 개발했고 그 중 다수가 오픈소스로 공개됐다.</li>
<li>상위 수준에서 보면 이 문제는 몇가지 다른 접근법이 있다.</li>
</ul>
</li>
</ul>
<ol>
<li>클라이언트가 아무 노드에나 접속하게 한다(예를 들어 라운드로빈 로드 밸런서를 통해). 만약 해당 노드에 마침 요청을 적용할 파티션이 있다면 거기서 요청을 직접 처리 할 수 있다.<br />
그렇지 않으면 요청을 올바른 노드로 전달해서 응답을 받고 클라이언트에게 응답을 전닳한다.</li>
<li>클라이언트의 모든 요청을 라우팅 계층으로 먼저 보낸다. 라우팅 계층에서는 각 요청을 처리할 노드를 알아내고 그에 따라 해동 노드로 요청을 전달한다.<br />
라우팅 계층 자체에서는 아무 요청도 처리하지 않는다. 파티션 인지(partition-aware)로드 밸런서로 동작할 뿐이다.</li>
<li>클라이언트가 파티셔닝 방법과 파티션이 어떤 노드에 할당됐는지를 알고 있게 한다. 이 경우 클라이언트는 중개자 없이 올바른 노드로 직접 접속할 수 있다.<br />
<img src="/images/data-intensive/chapter_6/service_discovery_node_routing.png" alt="" /></li>
</ol>
<ul>
<li>카산드라는 gossip protocol을 통해 클러스터 상태 변화를 노드 사이에 퍼뜨린다.</li>
</ul>
<h3 id="병렬-질의-실행"><a class="markdownIt-Anchor" href="#병렬-질의-실행"></a> 병렬 질의 실행</h3>
<ul>
<li>Massively parallel processing . MPP : 대규모 병렬 처리
<ul>
<li>join, filtering, grouping, aggregation 연산</li>
<li></li>
</ul>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/09/14/designing-data-intensive-application-4/">designing-data-intensive-application-4</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-14</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/data-intensive/">data intensive</a></span><div class="content"><h3 id="thrift"><a class="markdownIt-Anchor" href="#thrift"></a> Thrift</h3>
<ul>
<li>
<p>Binary Protocol<br />
<img src="/images/data-intensive/chapter_4/thrift_binary_protocol.png" alt="" /></p>
</li>
<li>
<p>Compact Protocol<br />
<img src="/images/data-intensive/chapter_4/thrift_compact_protocol.png" alt="" /></p>
<ul>
<li>variable-length integer : 가변 길이 정수 부호화
<ul>
<li>각 바이트의 상위 비트는 앞으로 더 많은 바이트가 있는지를 나타내는 데 사용한다.</li>
<li>-64 ~ 63 사이의 숫자는 1바이트로 부호화, -8192 ~ 8191 사이의 숫자는 2바이트로 부호화 한다는 의미</li>
</ul>
</li>
</ul>
</li>
</ul>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2022 By GwangHui Park</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>