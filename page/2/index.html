<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="GwangHui Park"><meta name="copyright" content="GwangHui Park"><title>History | Gwang Story</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">GwangHui Park</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">103</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">47</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">12</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Gwang Story</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Gwang Story</div><div id="site-sub-title">History</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2021/05/20/monitoring-prometheus/">monitoring-prometheus</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-05-20</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/monitoring/">monitoring</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/prometheus/">prometheus</a></span><div class="content"><h3 id="prometheus"><a class="markdownIt-Anchor" href="#prometheus"></a> Prometheus</h3>
<ul>
<li>Metric 기반 오픈소스 모니터링 시스템
<ul>
<li>데이터 모델 : Label (key-value time series)</li>
<li>쿼리 언어</li>
<li>CNCF 재단 멤버</li>
<li>Integration Library를 통해 third-party App들 연계 가능</li>
<li>알람 기능</li>
</ul>
</li>
</ul>
<h3 id="모니터링이란"><a class="markdownIt-Anchor" href="#모니터링이란"></a> 모니터링이란</h3>
<ul>
<li>Alerting(알림) : 문제가 발생한 시기나 시점을 파악하는 것이 모니터링에서는 가장 중요하다.</li>
<li>Debugging(디버깅) : 문제의 근본 원인을 규명하고 문제가 무엇이든 간에 반드시 해결해야 한다.</li>
<li>Trending(추세 파악) : 시스템이 어떻게 사용되고 시간에 따라 변화하는지를 확인할 수 있는 기능. Capacity Planning 과 같은 설계 결정과 프로세스에 영향을 미칠 수 있다.</li>
<li>Plumbing(플러밍) : 망치를 가지고 있으면, 모든 것이 못처럼 보이기 시작한다. 데이터 처리 파이프라인으로</li>
</ul>
<h3 id="모니터링의-범주"><a class="markdownIt-Anchor" href="#모니터링의-범주"></a> 모니터링의 범주</h3>
<ul>
<li>HTTP 요청 수신</li>
<li>HTTP 400 응답 송신</li>
<li>entering a function (함수 시작)</li>
<li>leaving a function (함수 종료)</li>
<li>if 문의 else에 도달</li>
<li>사용자 로그인</li>
<li>디스크에 데이터 쓰기</li>
<li>네트워크에서 데이터 읽기</li>
<li>커널에 추가 메모리 요청</li>
<li>모든 이벤트에는 컨텍스트가 있다.
<ul>
<li>HTTP 요청에는 들어오고 나가는 IP주소, 요청 URL 설정된 쿠키, 요청한 사용자 정보가 포함되어있다.</li>
<li>HTTP 응답에는 응답에 걸린 시간, HTTP 상태 코드, 응답 본문의 길이가 있다.</li>
<li>함수를 포함하는 이벤트에는 함수 상단에 있는 함수들의 콜 스택과 HTTP 요청처럼 무엇이 해당 스택의 일부를 트리거 했는지에 대한 정보가 담겨있다.</li>
</ul>
</li>
</ul>
<h3 id="프로파일링"><a class="markdownIt-Anchor" href="#프로파일링"></a> 프로파일링</h3>
<ul>
<li>profiling (프로파일링)은 우리가 모든 시간에 대해 모든 이벤트의 컨텍스트를 가질 수 없지만, 제한된 기간의 일부 컨텍스트를 가질 수 있다는 방식으로 접근한다.</li>
<li>Tcpdump는 프로파일링 도구의 하나로, 지정된 필터를 기반으로 네트워크 트래픽을 기록할 수 있다. Tcpdump는 필수적인 디버깅 도구지만, 실제로는 디스크 공간이 부족해 질수 있다.</li>
<li>리눅스 커널의 eBPF(enhanced Berkeley Packet Filters)는 파일시스템부터 네트워크 기호까지 커널 이벤트에 대해 상세하게 프로파일링을 할 수 있다.</li>
<li>오랜 시간 동안 프로프알링을 해야하는 경우, 다른 모니터링 방법과 함께 사용하려면 <em>반드시</em> 데이터의 양을 줄여야 한다.</li>
</ul>
<h3 id="트레이싱"><a class="markdownIt-Anchor" href="#트레이싱"></a> 트레이싱</h3>
<ul>
<li>tracing(트레이싱)은 모든 이벤트를 살펴보는 것이 아니라, 관심 기능을 통과하는 일부 이벤트 처럼 수백 개의 이벤트 중 특정 이벤트에만 집중한다.</li>
<li>Stack Trace에서 관심 있는 부분의 함수들을 기록하고, 때때로 이러한 함수들이 얼마나 오랫동안 수행되었는지도 기록한다.</li>
<li>트레이싱 시스템 중 일부는 관심 지정에서 스택 트레이스에 스냅샷을 수집하는 대신 관심 있는 함수 하위의 모든 함수 호출을 추적하고 타이밍을 기록한다.</li>
<li>HTTP 요청 중 하나를 샘플링할 수 있고, 이 요청에 대해 데이터베이스나 캐시같은 백엔드와 통신하는 데 얼마나 오랜 시간이 소비되었는지 확인할 수 있다.</li>
<li>Distributed tracing(분산 트레이싱)은 한단계 더 나아가 원격 프로시저 호출에서 다른 프로세스로 전달되는 요청에 고유 ID 를 추가해 해당 요청이 추적되어야 하는지 여부등 프로세스 전반에 걸친 작업을 추적한다.</li>
<li>트레이싱에서 데이터 볼륭 유지 및 계측 성능에 영향을 미치는 것은 sampling(샘플링)이다.</li>
</ul>
<h3 id="로깅"><a class="markdownIt-Anchor" href="#로깅"></a> 로깅</h3>
<ul>
<li>logging은 제한된 이벤트 집합을 살펴보고 각 이벤트에 대한 컨텍스트 일부를 기록한다.</li>
<li>로깅의 장점은 이벤트에 대한 샘플링이 없다는 점이다. 따라서 필드 개수를 제한하더라도, 시간이 오래 걸리는 요청이 특정 API 엔드포인트와 통신하는 특정 유저에게 얼마나 영향을 미치는지를 판단해야 한다.</li>
</ul>
<h4 id="로깅의-범주"><a class="markdownIt-Anchor" href="#로깅의-범주"></a> 로깅의 범주</h4>
<ul>
<li>Transaction Logs(트랜잭션 로그) : 어떠한 대가를 치르더라도 영원히 안전하게 보관해야 하는 중요한 비지니스 기록이다.<br />
주로 비용과 연관된 기능이나 사용자가 직접 사용하는 주요 기능이 트랜잭션 로그에 속한다.</li>
<li>Request logs(요청 로그) : 모든 HTTP 요청이나 데이터베이스 호출을 track(추적)하는 경우의 로그다.<br />
요청 로그는 사용자가 직접 사용하는 기능이나 내부 최적화의 구현에 쓰인다. 대부분은 요청 로그가 삭제되는 것을 바라지 않겠지만, 그렇다고 로그 중 일부를 잃는다고 해서 큰 문제가 되진 않는다.</li>
<li>Application Logs(애플리케이션 로그) : 모든 로그가 요청 로그인 것은 아니며, 프로세스 그 자체에 관한 로그도 있다. 시작 메시지, 백그라운드 유지보수 작업, 프로세스 수준의 로그<br />
주로 사람들이 직접 읽기 때문에 정상적인 동작에서 1분당 몇 개 정도가 적절하다.</li>
<li>Debug Logs(디버그 로그) : 디버그 로그는 굉장히 상세해서 생성과 저장에 비용이 많이 든다. 협소한 디버깅 상황에서만 사용되며, 데이터의 양 때문에 프로파일링의 특성을 띈다.</li>
</ul>
<h3 id="메트릭"><a class="markdownIt-Anchor" href="#메트릭"></a> 메트릭</h3>
<ul>
<li>metric(메트릭)은 컨텍스트를 대부분 무시하고 다양한 유형의 이벤트에 대해 시간에 따른 aggregation(집계)을 추적한다. 자원 사용을 정상적으로 유지하려면, 추적하는 메트릭의 개수를 제한해야한다.</li>
<li>프로세스당 1만개의 메트릭 처리정도가 합리적인 상한선 일 것이다.</li>
<li>metric을 이용하면 애플리케이션의 각 서브시스템에서의 대기 시간과 처리하는 데이터양을 추적해서 성능 저하의 원인이 정확히 무엇인지 손쉽게 알아낼 수 있다.</li>
<li>어떤 서브시스템에 문제의 원인이 있는지 찾아낸 다음, 로그를 통해 해당 문제에 관련된 사용자 요청을 정확하게 파악할 수 있다.</li>
<li>메트릭은 프로세스 전반에 걸쳐 이벤트 정보를 수집할 수 있지만, 일반적으로 카디널리티가 제한된 컨텍스트는 1~2개 이상의 필드를 갖지 않는다.</li>
<li>로그는 한 가지 유형 이벤트에 대해 모든 정보를 수집할 수 있지만, 카디널리티가 제한되지 않은 컨텍스트에 대해 수백 개 필드만 추적할 수 있다.</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/04/13/exchange-ready-april/">exchange-ready-april</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-13</time><div class="content"><h1 id="철이-없었죠-front-end-를-우습게-봤다는게"><a class="markdownIt-Anchor" href="#철이-없었죠-front-end-를-우습게-봤다는게"></a> 철이 없었죠… Front-End 를 우습게 봤다는게</h1>
<h1 id="front-end-역습"><a class="markdownIt-Anchor" href="#front-end-역습"></a> Front-end 역습</h1>
<h2 id="front-end-project-어떻게-시작하나"><a class="markdownIt-Anchor" href="#front-end-project-어떻게-시작하나"></a> Front-end Project 어떻게 시작하나?</h2>
<pre><code>##  Jquery를 썼다는건
</code></pre>
<h2 id="browser를-이해하면-front-end가-보인다"><a class="markdownIt-Anchor" href="#browser를-이해하면-front-end가-보인다"></a> Browser를 이해하면 Front-end가 보인다.</h2>
<ul>
<li>
<p>Dom Tree, CSS OM</p>
</li>
<li>
<p>Layout, Painting</p>
</li>
<li>
<p>javascript로 화면을 조작을 하면, Reflow와 Repainting이 일어나서 성능이 저하된다<br />
–&gt; 그래서 사람들이 Vue를 제어할때 onReady Event에 모아서 한번에 처리했었다.</p>
</li>
<li>
<p>SSR에서 SPA가 나온 이유</p>
<ul>
<li>정적 리소스 다운로드에 대한 비용</li>
<li>Ajax의 등장</li>
<li>패러다임 시프트가 일어나 Client Side Rendering 으로 전환</li>
<li>Client가 무거워짐</li>
<li>이를 잘 관리하기 위해 Framework들이 등장</li>
<li>Programming Model이 복잡해짐</li>
<li>view - data bind 양방향 선택
<ul>
<li>특정상황에서 느려짐</li>
</ul>
</li>
<li>이러한 부분에 대한것을 해결하기 위해 Virtual DOM을 쓰는 React의 등장</li>
<li>Flux Architecture 등장</li>
<li>React 와 VueJS 등장</li>
</ul>
</li>
<li>
<p>SPA --&gt; SSR로 다시</p>
<ul>
<li>SEO</li>
<li>Meta Tag들</li>
</ul>
</li>
<li>
<p>Static Page Generator</p>
</li>
<li>
<p>예전에 좋았는데 왜 지금 안좋아지는가?</p>
</li>
<li>
<p>HTTP2</p>
</li>
<li>
<p>Image Sprite</p>
</li>
<li>
<p>Protocol</p>
</li>
<li>
<p>HTTP</p>
</li>
</ul>
<h2 id="추가로-알면-좋은-것들-etc"><a class="markdownIt-Anchor" href="#추가로-알면-좋은-것들-etc"></a> 추가로 알면 좋은 것들 etc)</h2>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/03/29/designing-data-intensive-application-9/">designing-data-intensive-application-9</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-03-29</time><div class="content"><h3 id="데이터-일관성과-합의"><a class="markdownIt-Anchor" href="#데이터-일관성과-합의"></a> 데이터 일관성과 합의</h3>
<ul>
<li>분산 시스템에서는 내부 구성 요소 중 뭔가에 결함이 있더라도 서비스는 올바르게 동작할 방법을 찾아야 한다.</li>
<li>내결합성을 지닌 시스템을 구축하는 가장 좋은 방법은 유용한 보장을 해주는 범용 추상화를 찾아 이를 구현하고 애플리케이션에서 이 보장에 의존하게 하는 것이다.</li>
<li>분산 시스템에 가장 중요한 추상화 중 하나는 합의, 즉 모든 노드가 어떤 것에 동의하게 만드는 것이다.</li>
</ul>
<h3 id="일관성-보장"><a class="markdownIt-Anchor" href="#일관성-보장"></a> 일관성 보장</h3>
<ul>
<li>복제 데이터베이스는 대부분 최소한 최종적 일관성을 제공한다. (쓰기를 멈추고 불특정 시간 동안 기다리면 결국 모든 읽기 요청이 같은 값을 반환한다는 뜻이다.)</li>
<li>불일치는 일시적이며 결국 스스로 해소한다. 모든 복제본이 결국 같은 값으로 수렴되기를 기대하므로 최종적 일관성보다 수렴이 더 나은 이름일지도 모른다.</li>
<li>그러나 언제 복제본이 수렴될지에 대해서는 아무것도 이야기 하지 않는다.</li>
<li>최종적 일관성은 보통 단일 스레드 프로그램에 있는 변수 동작과 매우 다르므로 애플리케이션 개발자는 주의를 요한다.</li>
</ul>
<h3 id="선형성"><a class="markdownIt-Anchor" href="#선형성"></a> 선형성</h3>
<ul>
<li>최종적 일관성을 지닌 데이터베이스에서 두 개의 다른 복제본에 같은 질문을 동시에 하면 두 가지 다른 응답을 받을지도 모른다.
<ul>
<li>데이터 베이스가 본제본이 하나만 있다는 환상을 만들어 준다면 훨씬 더 단순 해지지 않을까? 그러면 모든 클라이언트는 똑같은 데이터를 보고 복제 지연을 걱정할 필요가 없다.</li>
</ul>
</li>
<li>위의 아이디어가 선형성을 뒷받침하는 아이디어다.
<ul>
<li>atomic consistency (원자적 일관성)</li>
<li>strong consistency (강한 일관성)</li>
<li>immediate consistency (즉각 일관성)</li>
<li>external consistency (외부 일관성)</li>
</ul>
</li>
<li>recency guarantee(최신성 보장) : 최근에 갱신된 값이며 뒤처진 캐시나 복제본에서 나온 값이 아니라고 보장<br />
<img src="/images/data-intensive/chapter_9/nonlinear_action.png" alt="" /></li>
<li>밥과 앨리스는 서로 다른 결과를 본다 (선형성 위반)</li>
</ul>
<h3 id="시스템에-선형성을-부여하는-것은-무엇인가"><a class="markdownIt-Anchor" href="#시스템에-선형성을-부여하는-것은-무엇인가"></a> 시스템에 선형성을 부여하는 것은 무엇인가?</h3>
<p><img src="/images/data-intensive/chapter_9/register.png" alt="" /></p>
<ul>
<li>선형 데이터베이스에서 동시에 같은 키 x를 읽고 쓰는 세 클라이언트를 보여준다. 분산 시스템 분야에서 x는 register(레지스터)라고 불린다.
<ul>
<li>현실에서는 키-값 저장소의 키 하나, 관계형 데이터베이스의 로우 하나, 또는 문서 데이터베이스의 문서 하나가 될 수 있다.</li>
</ul>
</li>
<li>이 예제에서 레지스터는 두 가지 종류 연산이 있다.
<ul>
<li>read(x) =&gt; v는 클라이언트가 레지스터 x의 값을 읽기를 요청했고 데이터베이스가 값 v를 반환했다는 것을 의미한다.</li>
<li>write(x) =&gt; v은 클라이언트가 레지스터 x의 값을 v로 설정하라고 요청했고 데이터베이스가 응답r(ok or error)을 반환했다는 것을 의미한다.</li>
</ul>
</li>
<li>실행되는 동안 클라이언트 A와 B는 최신 값을 읽기 위해 반복적으로 데이터베이스를 폴링한다. A와 B는 자신의 읽기 요청에 대해 어떤 응답을 받을 수 있을까?
<ul>
<li>A의 첫 연산은 0을 반환하는 것이 명백하다</li>
<li>A의 마지막 읽기 연산은 쓰기가 완료된 후 시작하므로 데이터베이스가 선형적이라면 명백히 새로운 값 1을 반환해야 한다. 쓰기는 쓰기 연산의 시작과 끝 사이의 어느 시점에선가 처리됐어야 하고 읽기는 읽기 연산의 시작과 끝 사이의 어느 시점에선가 처리 됐어야 한다. 만약 쓰기가 끝난 후에 읽기가 시작하면 그 읽기는 쓰기 후에 처리됐어야 하고 따라서 새로 쓰여진 값을 볼 수 있어야 한다.</li>
<li>쓰기 연산과 시간이 겹치는 읽기 연산은 0을 반환했을 수도 1을 반환했을 수도 있다. 읽기 연산이 처리되는 시점에 쓰기의 영향이 발생했는지 아닌지 알 수 없기 때문이다. 이 연산들은 쓰기와 동시에 실행된다.</li>
</ul>
</li>
<li>시스템을 선형적으로 만들려면 또 다른 제약조건을 추가해야 한다.<br />
<img src="/images/data-intensive/chapter_9/register_constraint.png" alt="" /></li>
<li>선형성 시스템에서 우리는 x의 값이 원자적으로 0에서 1로 바뀌는 어떤 시점이 있어야 한다고 상상한다. 따라서 한 클라이언트의 읽기가 새로운 값 1을 반환하면 이후의 모든 읽기 또한 새로운 값을 반환해야 한다.
<ul>
<li>A는 새로운 값 1을 읽은 첫번째 클라이언트다. A의 읽기가 반환된 후 바로 B가 새로운 읽기를 시작한다. B의 읽기는 확실히 A의 읽기 뒤에 실행되므로 C가 실행한 쓰기가 아직 진행 중이라도 역시 1을 반환해야 한다.</li>
<li>하나의 연산을 더 추가한다.
<ul>
<li>cas(x, v_old, v_new) =&gt; r 은 클라이언트가 atomic compare-and-set 연산을 요청했다는 뜻이다. 레지스터 x의 현재 값이 v_old와 같으면 원자적으로 v_new로 설정돼야 한다. X != v_old 라면 이 연산은 레지스터를 그대로 두고 오류를 반환해야 한다. r(ok or error)은 데이터베이스의 응답이다.<br />
<img src="/images/data-intensive/chapter_9/register_cas.PNG" alt="" /></li>
</ul>
</li>
<li>클라이언트 B가 X 읽기 요청을 보낸 후 클라이언트 D가 x를 0으로 설정하는 요청을 보내고 클라이언트 A가 x를 1로 설정하는 요청을 보낸다. 그렇지만 B의 읽기가 반환한 값은 1이다. 이것은 문제가 없으며 데이터베이스가 D의 쓰기를 먼저 처리한 수 A의 쓰기를 처리했고 마지막으로 B의 읽기를 처리했다는 의미다. 요청을 보낸 순서와는 다르지만 세 요청이 동시적이기 때문에 이는 허용된다.</li>
<li>클라이언트 B의 읽기는 클라이언트 A가 데이터베이스로부터 값을 1로 쓰는 데 성공했다는 응답을 받기 전에 1을 반환했다. 이것도 괜찮다. 값이 쓰여지기 전에 읽혔다는 의미가 아니라 데이터베이스에서 클라이언트 A로 가는 ok응답이 네트워크에서 약간 지연됐다는 의미이다.</li>
<li>이 모델은 어떤 트랜잭션 격리도 가정하지 않는다. 다른 클라이언트가 언제라도 값을 바꿀지 모른다. 예를 들어 C는 먼저 1을 읽고 그 다음에는 2를 읽었는데, 두 번의 읽기 사이에 B가 값을 변경했기 때문이다. 다른 클라이언트가 동시에 값을 바꾸지 않았는지 확인하기 위해 atomic compare and set 연산을 쓸 수 있다. B와 C의 cas 요청은 성공하지만 D의 cas 요청은 실패다 (데이터베이스가 그 요청을 처리하는 시점에 x의 값은 더 이상 0이 아니다.)</li>
<li>클라이언트 B의 마지막 읽기는 선형적이지 않다. 이 연산은 x를 2에서 4로 갱신하는 C의 cas 쓰기와 동시적이다. 다른 요청이 없다면 B의 읽기가 2를 반환해도 괜찮다. 그러나 클라이언트 A는 B의 읽기가 시작하기 전에 이미 새로운 값 4를 읽었다. 따라서 B는 A가 읽은 것보다 과거의 값을 읽는 것은 허용되지 않는다.</li>
</ul>
</li>
</ul>
<h3 id="선형성-대-직렬성"><a class="markdownIt-Anchor" href="#선형성-대-직렬성"></a> 선형성 대 직렬성</h3>
<ul>
<li>직렬성
<ul>
<li>모든 트랜잭션이 여러 객체(로우, 문서, 레코드)를 읽고 쓸 수 있는 상황에서의 트랜잭션들의 격리 속성이다. 직렬성은 트랜잭션이 어떤 순서에 따라 실행되는 것처럼 동작하도록 보장해준다. 그 순서가 트랜잭션들이 실제로 실행되는 순서와 달라도 상관없다.</li>
</ul>
</li>
<li>선형성
<ul>
<li>레지스터(개볍 객체)에 실행되는 읽기와 쓰기에 대한 최신성 보장이다. 선형성은 연산을 트랜잭션으로 묶지 않아서 충돌 구체와 같은 부가적인 수단을 사용하지 않으면 쓰기 스큐 같은 문제를 막지 못한다.</li>
</ul>
</li>
<li>데이터베이스는 직렬성과 선형성을 모두 제공할 수도 있으며 이런 조합은 strict serializability (엄격한 직렬성)이나 strong one-copy serializability, strong-1SR(강한 단일 복사본 직렬성)이라고 한다.
<ul>
<li>2단계 잠금(2PL)이나 실제적인 직렬실행을 기반으로 한 직렬성 구현은 보통 선형적이다.</li>
</ul>
</li>
<li>그러나 직렬성 스냅숏 격리(SSI)는 선형적이지 않다. SSI 는 읽는 쪽이나 쓰는 쪽 사이의 잠금 경쟁을 피하기 위해 일관된 스냅숏에서 읽는다. 요점은 스냅숏에 스냅숏보다 나중에 실행된 쓰기를 포함하지 않는다는 것이고 따라서 스냅숏에서 읽으면 선형적이지 않다.</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/03/24/byzantine-generals-problem/">byzantine-generals-problem</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-03-24</time><div class="content"><h3 id="비잔틴-장군-문제"><a class="markdownIt-Anchor" href="#비잔틴-장군-문제"></a> 비잔틴 장군 문제</h3>
<ul>
<li>이른바 두 장군 문제(Two Generals Problem)을 일반화한 것이다.</li>
<li>이 문제에서는 두 군대의 장군이 전투 계획에 동의해야 하는 상황을 가정한다. 이들은 다른 두 장소에 캠프를 세우기 때문에 전령을 통해서만 연락을 주고받을 수 있고 전령은 때때로 (네트워크의 패킷처럼) 늦거나 실종되기도 한다.</li>
<li>비잔틴 버전 문제에서는 n명의 장군이 동의해야 하며 그들의 노력은 그들 가운데 배신자들이 있다는 사실에 방해를 받는다. 장군들은 대부분 충성스럽고 따라서 진실한 메세지를 보내지만 배신자들은 (발각되지 않으려고 노력하며) 가짜나 허위 메세지를 보내 다른 장군들을 속이거나 혼란스럽게 하려고 시도할지도 모른다. 누가 배신자인지는 미리 알려지지 않는다.</li>
<li>Byzantium(비잔티움)은 고대 그리스 도시였으며 나중에 콘스탄티노플이 됐다. 현재는 터키의 이스탄불이다.</li>
<li>비잔티움의 장군들이 다른 곳의 장군들보다 모의나 음모를 더 꾸민다는 어떤 역사적 증거도 없다.</li>
<li>그보다는 심하게 복잡하고 관료주의적이며 정직하지 못하다는 뜻에서 비잔틴으로부터 이름이 유래됐으며 컴퓨터가 나오기 오래 전에 정치에서 사용됐다.</li>
<li>Lamport(램포트)는 어떤 독자도 불쾌하지 않을 국적을 고르기를 원했고<br />
The Albanian Generals Problem(알바니아 장군 문제)라고 부르는 것은 그리 좋은 생각이 아니라는 조언을 들었다.</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/02/15/time-series-data-base-key-concept/">time-series-data-base-key-concept</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-02-15</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/tsdb/">tsdb</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/influxdb/">influxdb</a></span><div class="content"><h3 id="time-ordered-data"><a class="markdownIt-Anchor" href="#time-ordered-data"></a> Time-ordered Data</h3>
<ul>
<li>성능 향상을 위해 데이터는 시간 오름차순으로 기록된다.</li>
</ul>
<h3 id="strict-update-and-delete-permissions"><a class="markdownIt-Anchor" href="#strict-update-and-delete-permissions"></a> Strict update and delete permissions</h3>
<ul>
<li>질의, 쓰기 성능 향상을 위해 update와 delete 를 엄격히 제한한다. 시계열 데이터는 주로 업데이트 되지 않는 새로운 데이터이기 때문이다.<br />
삭제는 일반적으로 기록되지 않는 데이터에만 영향을 미치며 update와 충돌은 일어나지 않는다.</li>
</ul>
<h3 id="handle-read-and-write-queries-first"><a class="markdownIt-Anchor" href="#handle-read-and-write-queries-first"></a> Handle read and write queries first</h3>
<ul>
<li>일관성 보다는 읽기 및 쓰기 요청의 우선순위를 지정한다. 쿼리가 실행될 때의 결과를 반환하기 때문에 쿼리 된 데이터에 영향을 주는 모든 트랜잭션은 이후에 처리 되어<br />
데이터가 궁극적으로 일관성을 유지하도록 한다. 수집속도가 높으면 쿼리 결과에 최신 데이터가 포함되지 않을 수 있다.</li>
</ul>
<h3 id="schemaless-design"><a class="markdownIt-Anchor" href="#schemaless-design"></a> Schemaless design</h3>
<ul>
<li>스키마없는 디자인을 사용해 불연속 데이터를 더 잘 관리하도록 한다. 시계열 데이터는 일시적이므로 데이터가 몇시간동안 표시되었다가 사라진다.</li>
</ul>
<h3 id="datasets-over-individual-points"><a class="markdownIt-Anchor" href="#datasets-over-individual-points"></a> Datasets over individual points</h3>
<ul>
<li>데이터 세트가 개별 포인트보다 더 중요하기 때문에 influxDB는 데이터를 집계하고 대규모 데이터 세트를 처리하는 강력한 도구를 구현한다.<br />
포인트는 타임 스탬프 및 시리즈로 구분되므로 전통적인 의미의 ID가 존재하지 않는다.</li>
</ul>
<h3 id="duplicate-data"><a class="markdownIt-Anchor" href="#duplicate-data"></a> Duplicate data</h3>
<ul>
<li>충돌 해결을 단순화하고 쓰기 성능을 높이기 위해 influxDB는 여러번 전송된 데이터가 중복데이터라고 가정합니다. 동일한 포인트는 두번 저장되지 않습니다.<br />
포인트에 대한 새 필드 값이 제출되면 influxDB는 가장 최근 필드값으로 포인트를 업데이트 합니다. 드문 경우지만 데이터를 덮어 쓸 수 있다.</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/02/14/kafka-cli-cheat-sheet/">kafka-cli-cheat-sheet</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-02-14</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/kafka/">kafka</a></span><div class="content"><h3 id="daemon으로-kafka-실행"><a class="markdownIt-Anchor" href="#daemon으로-kafka-실행"></a> Daemon으로 kafka 실행</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./bin/zookeeper-server-start.sh -daemon config/zookeeper.properties</span><br><span class="line">./bin/kafka-server-start.sh -daemon config/server.properties</span><br></pre></td></tr></table></figure>
<h3 id="topic-생성"><a class="markdownIt-Anchor" href="#topic-생성"></a> Topic 생성</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic notification-topic</span><br></pre></td></tr></table></figure>
<h3 id="message-publish"><a class="markdownIt-Anchor" href="#message-publish"></a> Message Publish</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-console-producer.sh --broker-list localhost:9092 --topic notification-topic</span><br></pre></td></tr></table></figure>
<h3 id="produce-messages-to-a-kafka-topic-from-a-file"><a class="markdownIt-Anchor" href="#produce-messages-to-a-kafka-topic-from-a-file"></a> produce messages to a kafka topic from a file</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-console-producer.sh --broker-list localhost:9092 --topic notification-topic &lt; topic-input.txt</span><br></pre></td></tr></table></figure>
<h3 id="produce-messages-to-kafka-with-both-key-and-value"><a class="markdownIt-Anchor" href="#produce-messages-to-kafka-with-both-key-and-value"></a> Produce messages to Kafka with both key and value</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-console-producer.sh --broker-list localhost:9092 --topic notification-topic --property parse.key=true --property key.separator=:</span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/01/29/spring-boot-application-runner/">spring-boot-application-runner</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-01-29</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/springboot/">springboot</a></span><div class="content"><h3 id="commandlinerunner"><a class="markdownIt-Anchor" href="#commandlinerunner"></a> CommandLineRunner</h3>
<ul>
<li>실행되는 코드가 자바 문자열 아규먼트 배열에 접근해야 할 필요가 있는 경우에 사용.</li>
<li>CommandLineRunner 인터페이스를 구현한 클래스에 @Component 어노테이션을 선언해두고 컴포넌트 스캔 이후 구동 시점에 run 메소드 실행</li>
</ul>
<h3 id="applicationrunner"><a class="markdownIt-Anchor" href="#applicationrunner"></a> ApplicationRunner</h3>
<ul>
<li>실행되는 코드가 아규먼트에 접근하고 싶으나 추상화된 ApplicationArguments 타입의 객체를 받고 싶을 때 사용</li>
<li>CommandLineRunner 인터페이스를 구현한 클래스에 @Component 어노테이션을 선언해두고 컴포넌트 스캔 이후 구동 시점에 run 메소드 실행</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/01/28/kafka-definition-guide-6/">kafka-definition-guide-6</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-01-28</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/kafka/">kafka</a></span><div class="content"><h3 id="신뢰성-있는-시스템에서-프로듀서-사용하기"><a class="markdownIt-Anchor" href="#신뢰성-있는-시스템에서-프로듀서-사용하기"></a> 신뢰성 있는 시스템에서 프로듀서 사용하기</h3>
<ul>
<li>
<p>시나리오 1</p>
<ul>
<li>replica 3, unclean leader election, producer ack 1</li>
<li>프로듀서가 메세지를 전송하면 리더에 쓰게 되지만 동기화 리플리카에는 아직 쓰지 않은 상황</li>
<li>리더는 프로듀서에게 ‘메세지를 성공적으로 썼음’ 응답 후 데이터가 다른 리플리카에 복제되기 전에 곧바로 중단</li>
<li>이 경우 in-sync replica로 간주된 하나의 replica 가 리더가 됨</li>
<li>메세지는 새로 리더가 된 리플리카에 쓰지 않았으므로 유실</li>
</ul>
</li>
<li>
<p>시나리오 2</p>
<ul>
<li>replica 3, unclean leader election, producer ack all</li>
<li>쓰려고 하는데 해당 파티션의 리더가 방금 중단되어 새로운 리더 선출 중</li>
<li>카프카는 ‘사용할 수 있는 리더가 없음’ 에러 응답</li>
<li>쓰기가 성공적으로 될 때까지 프로듀서가 해당 에러를 제대로 처리하지 못해 재시도 하지 않는 다면 메세지 유실</li>
</ul>
</li>
<li>
<p>신뢰성 요구 사항에 맞도록 acks 구성 매개변수를 올바르게 설정해야 한다.</p>
</li>
<li>
<p>구성 매개변수와 코드 모두에서 에러 처리를 올바르게 해야 한다.</p>
</li>
</ul>
<h3 id="확인-응답-전송"><a class="markdownIt-Anchor" href="#확인-응답-전송"></a> 확인 응답 전송</h3>
<ul>
<li>
<p>acks = 0 : 프로듀서가 네트어ㅜ크로 메세지를 전송했다면 카프카가 성공적으로 쓴 것으로 간주</p>
<ul>
<li>전송하는 개체가 직렬화 될 수 없거나, 네트워크 카드 장애가 생기면 프로듀서가 에러를 받음</li>
<li>그러나 메세지를 쓸 파티ㅕㅅㄴ이 오프라인이거나 관련 카프카 클러스터의 처리가 늦어지는 경우는 에러를 받지 않음. 이에 리더 선출이 예상되는 상황의 메세지는 유실될 가능성 존재</li>
</ul>
</li>
<li>
<p>acks = 1 : 리더가 메시지를 수신하고 파티션 데이터 파일에 쓴 후 확인 응답 또는 에러를 전송한다.</p>
<ul>
<li>리더 선출 중일 경우 프로듀서는 LeaderNotAvailable Exception 예외 발생</li>
<li>프로듀서가 이 예외를 올바르게 처리한다면 해당 메세지를 다시 전송하여 새로운 리더가 수신하게 됨</li>
</ul>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/01/18/kafka-definition-guide-1/">kafka-definition-guide-1</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-01-18</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/kafka/">kafka</a></span><div class="content"><h3 id="keyword"><a class="markdownIt-Anchor" href="#keyword"></a> Keyword</h3>
<ul>
<li>page cache : 카프카는 프로듀서에게 빠른 응답 시간을 제공하기 위해 디스크 입출력 성능에 의존한다. !!</li>
<li>dirty memory page</li>
<li>swap space</li>
<li>vm.swappiness : 이 매개변수의 값은 비율이며, 페이지 캐시의 페이지들을 삭제하지 않고 스와핑 공간을 얼마나 사용할지 나타낸다.</li>
<li>linux file system
<ul>
<li>EXT4</li>
<li>XFS</li>
</ul>
</li>
<li>File Metadata
<ul>
<li>ctime : 생성 시간</li>
<li>mtime : 마지막 수정 시간</li>
<li>atime : 마지막 사용 시간</li>
</ul>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/01/05/authentication-saml/">authentication-saml</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-01-05</time><div class="content"><h3 id="saml-security-assertion-markup-language"><a class="markdownIt-Anchor" href="#saml-security-assertion-markup-language"></a> SAML (Security Assertion Markup Language)</h3>
<ul>
<li>용어
<ul>
<li>Authentication(인증) : 사용자가 자신이 주장하는 사람임을 확인</li>
<li>Authorization(권한 부여) : 사용자가 특정 시스템이나 콘텐츠에 접속할 수 있는 권한이 있는지 확인</li>
<li>Service Provider(서비스 제공자) : 시스템에서 사용자가 원하는 서비스를 제공하는 제공자</li>
<li>Identity Provider(인증 정보 제공자) : 사용자의 크레덴셜(사용자 ID와 패스워드)을 인증하고 SAML Assertion을 발행하는 주체</li>
<li>SAML Assertion(SAML 보안 정보) : 사용자 인증을 위해 Identity Provider로 부터 Service Provider로 전달되는 보안정보<br />
사용자명, 권한 등의 내용을 적은 XML 문서로 변조를 막기 위해 전자 서명 되어있다.</li>
<li>SAML Request (인증 요청) : Service Provider가 생성ㅁ하는 인증 요청으로 Identity Provider로 인증 위임</li>
<li>Circle of Trust : 하나의 Identity Provider를 공유하는 Service Provider 들로 구성</li>
<li>Metadata : SSO를 활성화 하는 Service Provider 및 Identity Provider가 생성하는 XML 파일<br />
웹 어플리케이션의 경우 프로비저닝시에 Service Provider와 Identity Provider간 메타데이터(Entity Id, 암호화 키, Endpoint)의 교환으로 신뢰 관계 설립</li>
<li>Assertion Consumer Service URL : Identity Provider가 특정 URL로 최종 SAML 응답을 포스트 하도록 요구한다.</li>
</ul>
</li>
</ul>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2022 By GwangHui Park</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>